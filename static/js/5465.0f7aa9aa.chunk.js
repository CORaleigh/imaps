"use strict";(globalThis.webpackChunkimaps=globalThis.webpackChunkimaps||[]).push([[5465],{75465:(t,e,s)=>{s.r(e),s.d(e,{DictionaryLoader:()=>p});var i=s(51995),o=s(76200),r=s(10064),n=s(32718),a=s(16054),l=s(92026),c=s(66978),h=s(643),y=s(819),m=s(75021);const u=n.Z.getLogger("esri.renderers.support.DictionaryLoader"),f={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class p{constructor(t,e,s){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new a.Z(100),this.url=t,this.config=e,this.fieldMap=s}getSymbolFields(){return this._symbolFields}async getSymbolAsync(t,e){let s;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(e));try{s=await this._dictionaryPromise}catch(d){if((0,c.D_)(d))return this._dictionaryPromise=null,null}const o={};if(this.fieldMap)for(const i of this._symbolFields){const e=this.fieldMap[i];if(e&&null!=t.attributes[e]){const s=""+t.attributes[e];o[i]=s}else o[i]=""}const r=s(o,e);if(!r||"string"!=typeof r)return null;const n=(0,h.hP)(r).toString(),a=this._symbolCache.get(n);if(a)return a.catch((()=>{this._symbolCache.pop(n)})),a;const y=r.split(";"),m=[],u=[];for(const l of y)if(l)if(l.includes("po:")){const t=l.substr(3).split("|");if(3===t.length){const e=t[0],s=t[1];let o=t[2];if("DashTemplate"===s)o=o.split(" ").map((t=>Number(t)));else if("Color"===s){const t=new i.Z(o).toRgba();o=[t[0],t[1],t[2],255*t[3]]}else o=Number(o);u.push({primitiveName:e,propertyName:s,value:o})}}else if(l.includes("|")){for(const t of l.split("|"))if(this._itemNames.has(t)){m.push(t);break}}else this._itemNames.has(l)&&m.push(l);const f=!(0,l.pC)(t.geometry)||!t.geometry.hasZ&&"point"===t.geometry.type,p=this._cimPartsToCIMSymbol(m,u,f,e);return this._symbolCache.put(n,p,1),p}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void u.error("no valid URL!");const e=(0,o.default)(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:(0,l.pC)(t)?t.signal:null}),[{data:s}]=await Promise.all([e,(0,y.LC)()]);if(!s)throw this._dictionaryPromise=null,new r.Z("esri.renderers.DictionaryRenderer","Bad dictionary data!");const i=s.expression,n=s.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+s.cimRefTemplateUrl,this._itemNames=new Set(s.itemsNames),this._symbolFields=n.symbol;const a={};if(this.config){const t=this.config;for(const e in t)a[e]=t[e]}if(n.configuration)for(const o of n.configuration)a.hasOwnProperty(o.name)||(a[o.name]=o.value);const c=[];if((0,l.pC)(t)&&t.fields&&this.fieldMap)for(const o of this._symbolFields){const e=this.fieldMap[o],s=t.fields.filter((t=>t.name===e));s.length>0&&c.push({...s[0],name:o})}return this._dictionaryPromise=(0,y.pp)(i,(0,l.pC)(t)?t.spatialReference:null,c,a).then((t=>{const e={scale:0};return(s,i)=>{const o=t.repurposeFeature({geometry:null,attributes:s});return e.scale=(0,l.pC)(i)?i.scale:void 0,t.evaluate({$feature:o,$view:e})}})).catch((t=>(u.error("Creating dictinoary expression failed:",t),null))),this._dictionaryPromise}async _cimPartsToCIMSymbol(t,e,s,i){const o=new Array(t.length);for(let a=0;a<t.length;a++)o[a]=this._getSymbolPart(t[a],i);const r=await Promise.all(o),n=this.fieldMap;for(const a of r)d(a,n);return new m.Z({data:this._combineSymbolParts(r,e,s)})}async _getSymbolPart(t,e){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then((t=>t.data));const s=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,t),i=(0,o.default)(s,{responseType:"json",query:{f:"json"},...e});this._ongoingRequests.set(t,i);try{return(await i).data}catch(r){throw this._ongoingRequests.delete(t),r}}_combineSymbolParts(t,e,s){if(!t||0===t.length)return null;const i={...t[0]};if(t.length>1){i.symbolLayers=[];for(const e of t){const t=e;i.symbolLayers.unshift(...t.symbolLayers)}}return s&&(i.callout=f),{type:"CIMSymbolReference",symbol:i,primitiveOverrides:e}}}function d(t,e){if(!t)return;const s=t.symbolLayers;if(!s)return;let i=s.length;for(;i--;){const t=s[i];t&&!1!==t.enable&&"CIMVectorMarker"===t.type&&b(t,e)}}function b(t,e){const s=t.markerGraphics;if(s)for(const i of s){if(!i)continue;const t=i.symbol;if(t)switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":d(t,e);break;case"CIMTextSymbol":t.fieldMap=e}}}},75021:(t,e,s)=>{s.d(e,{Z:()=>p});var i,o=s(27366),r=s(84652),n=s(643),a=s(49861),l=(s(25243),s(27135)),c=s(38511),h=s(69912),y=s(31201),m=s(37270),u=s(22061);let f=i=class extends u.Z{constructor(t){super(t),this.data=null,this.type="cim"}readData(t,e){return e}writeData(t,e){if(t)for(const s in t)e[s]=t[s]}async collectRequiredFields(t,e){if("CIMSymbolReference"===this.data.type){const s=this.data.primitiveOverrides;if(s){const i=s.map((s=>{const i=s.valueExpressionInfo;return(0,m.io)(t,e,i.expression)}));await Promise.all(i)}}}clone(){return new i({data:(0,r.d9)(this.data)})}hash(){return(0,n.hP)(JSON.stringify(this.data)).toString()}};(0,o._)([(0,a.Cb)({json:{write:!1}})],f.prototype,"color",void 0),(0,o._)([(0,a.Cb)({json:{write:!0}})],f.prototype,"data",void 0),(0,o._)([(0,c.r)("data",["symbol"])],f.prototype,"readData",null),(0,o._)([(0,y.c)("data",{})],f.prototype,"writeData",null),(0,o._)([(0,l.J)({CIMSymbolReference:"cim"},{readOnly:!0})],f.prototype,"type",void 0),f=i=(0,o._)([(0,h.j)("esri.symbols.CIMSymbol")],f);const p=f}}]);
//# sourceMappingURL=5465.0f7aa9aa.chunk.js.map