"use strict";(globalThis.webpackChunkimaps=globalThis.webpackChunkimaps||[]).push([[3518],{47991:(t,e,i)=>{i.d(e,{SR:()=>c,Ui:()=>l});var s=i(92026),n=i(65156),r=i(376),o=i(69662),h=i(77981),a=i(76335),u=i(92975);function l(t){return p(t,!0)}function c(t){return p(t,!1)}function p(t,e){if((0,s.Wi)(t))return null;const i=t.spatialReference,n=(0,u.C5)(i),o="toJSON"in t?t.toJSON():t;if(!n)return o;const l=(0,u.sS)(i)?102100:4326,c=a.UZ[l].maxX,p=a.UZ[l].minX;if((0,h.wp)(o))return m(o,c,p);if((0,h.aW)(o))return o.points=o.points.map((t=>m(t,c,p))),o;if((0,h.YX)(o))return d(o,n);if((0,h.oU)(o)||(0,h.l9)(o)){const t=(0,r.$P)(v,o),i={xmin:t[0],ymin:t[1],xmax:t[2],ymax:t[3]},s=(0,a.XZ)(i.xmin,p)*(2*c),n=0===s?o:(0,a.Sy)(o,s);return i.xmin+=s,i.xmax+=s,i.xmax>c?_(n,c,e):i.xmin<p?_(n,p,e):n}return o}function d(t,e){if(!e)return t;const i=function(t,e){const i=[],{ymin:s,ymax:n,xmin:r,xmax:o}=t,h=t.xmax-t.xmin,[a,u]=e.valid,{x:l,frameId:c}=x(t.xmin,e),{x:p,frameId:d}=x(t.xmax,e),m=l===p&&h>0;if(h>2*u){const t={xmin:r<o?l:p,ymin:s,xmax:u,ymax:n},e={xmin:a,ymin:s,xmax:r<o?p:l,ymax:n},h={xmin:0,ymin:s,xmax:u,ymax:n},m={xmin:a,ymin:s,xmax:0,ymax:n},x=[],y=[];f(t,h)&&x.push(c),f(t,m)&&y.push(c),f(e,h)&&x.push(d),f(e,m)&&y.push(d);for(let i=c+1;i<d;i++)x.push(i),y.push(i);i.push(new g(t,[c]),new g(e,[d]),new g(h,x),new g(m,y))}else l>p||m?i.push(new g({xmin:l,ymin:s,xmax:u,ymax:n},[c]),new g({xmin:a,ymin:s,xmax:p,ymax:n},[d])):i.push(new g({xmin:l,ymin:s,xmax:p,ymax:n},[c]));return i}(t,e).map((t=>t.extent));return i.length<2?i[0]||t:i.length>2?(t.xmin=e.valid[0],t.xmax=e.valid[1],t):{rings:i.map((t=>[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]))}}function m(t,e,i){if(Array.isArray(t)){const s=t[0];if(s>e){const i=(0,a.XZ)(s,e);t[0]=s+i*(-2*e)}else if(s<i){const e=(0,a.XZ)(s,i);t[0]=s+e*(-2*i)}}else{const s=t.x;if(s>e){const i=(0,a.XZ)(s,e);t.x+=i*(-2*e)}else if(s<i){const e=(0,a.XZ)(s,i);t.x+=e*(-2*i)}}return t}function x(t,e){const[i,s]=e.valid,n=2*s;let r,o=0;return t>s?(r=Math.ceil(Math.abs(t-s)/n),t-=r*n,o=r):t<i&&(r=Math.ceil(Math.abs(t-i)/n),t+=r*n,o=-r),{x:t,frameId:o}}function f(t,e){const{xmin:i,ymin:s,xmax:n,ymax:r}=e;return y(t,i,s)&&y(t,i,r)&&y(t,n,r)&&y(t,n,s)}function y(t,e,i){return e>=t.xmin&&e<=t.xmax&&i>=t.ymin&&i<=t.ymax}function _(t,e){let i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const s=!(0,h.l9)(t);if(s&&(0,o.Zy)(t),i)return(new S).cut(t,e);const n=s?t.rings:t.paths,r=s?4:2,a=n.length,u=-2*e;for(let o=0;o<a;o++){const t=n[o];if(t&&t.length>=r){const e=[];for(const i of t)e.push([i[0]+u,i[1]]);n.push(e)}}return s?t.rings=n:t.paths=n,t}class g{constructor(t,e){this.extent=t,this.frameIds=e}}const v=(0,n.Ue)();class S{constructor(){this.linesIn=[],this.linesOut=[]}cut(t,e){let i;if(this.xCut=e,t.rings)this.closed=!0,i=t.rings,this.minPts=4;else{if(!t.paths)return null;this.closed=!1,i=t.paths,this.minPts=2}for(const n of i){if(!n||n.length<this.minPts)continue;let t=!0;for(const e of n)t?(this.moveTo(e),t=!1):this.lineTo(e);this.closed&&this.close()}this._pushLineIn(),this._pushLineOut(),i=[];for(const n of this.linesIn)n&&n.length>=this.minPts&&i.push(n);const s=-2*this.xCut;for(const n of this.linesOut)if(n&&n.length>=this.minPts){for(const t of n)t[0]+=s;i.push(n)}return this.closed?t.rings=i:t.paths=i,t}moveTo(t){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(t[0]),this._moveTo(t[0],t[1],this._prevSide),this._prevPt=t,this._firstPt=t}lineTo(t){const e=this._side(t[0]);if(e*this._prevSide==-1){const i=this._intersect(this._prevPt,t);this._lineTo(this.xCut,i,0),this._prevSide=0,this._lineTo(t[0],t[1],e)}else this._lineTo(t[0],t[1],e);this._prevSide=e,this._prevPt=t}close(){const t=this._firstPt,e=this._prevPt;t[0]===e[0]&&t[1]===e[1]||this.lineTo(t),this._checkClosingPt(this.lineIn),this._checkClosingPt(this.lineOut)}_moveTo(t,e,i){this.closed?(this.lineIn.push([i<=0?t:this.xCut,e]),this.lineOut.push([i>=0?t:this.xCut,e])):(i<=0&&this.lineIn.push([t,e]),i>=0&&this.lineOut.push([t,e]))}_lineTo(t,e,i){this.closed?(this._addPolyVertex(this.lineIn,i<=0?t:this.xCut,e),this._addPolyVertex(this.lineOut,i>=0?t:this.xCut,e)):i<0?(0===this._prevSide&&this._pushLineOut(),this.lineIn.push([t,e])):i>0?(0===this._prevSide&&this._pushLineIn(),this.lineOut.push([t,e])):this._prevSide<0?(this.lineIn.push([t,e]),this.lineOut.push([t,e])):this._prevSide>0&&(this.lineOut.push([t,e]),this.lineIn.push([t,e]))}_addPolyVertex(t,e,i){const s=t.length;s>1&&t[s-1][0]===e&&t[s-2][0]===e?t[s-1][1]=i:t.push([e,i])}_checkClosingPt(t){const e=t.length;e>3&&t[0][0]===this.xCut&&t[e-2][0]===this.xCut&&t[1][0]===this.xCut&&(t[0][1]=t[e-2][1],t.pop())}_side(t){return t<this.xCut?-1:t>this.xCut?1:0}_intersect(t,e){const i=(this.xCut-t[0])/(e[0]-t[0]);return t[1]+i*(e[1]-t[1])}_pushLineIn(){this.lineIn&&this.lineIn.length>=this.minPts&&this.linesIn.push(this.lineIn),this.lineIn=[]}_pushLineOut(){this.lineOut&&this.lineOut.length>=this.minPts&&this.linesOut.push(this.lineOut),this.lineOut=[]}}},33518:(t,e,i)=>{i.r(e),i.d(e,{GraphicsSnappingSource:()=>S});var s=i(27366),n=i(85015),r=i(63780),o=i(41691),h=i(92026),a=i(66978),u=i(49861),l=(i(93169),i(25243),i(69912)),c=i(80885),p=i(79803),d=i(47991),m=i(27823),x=i(83406),f=i(3182),y=i(68928),_=i(14e3),g=i(64674),v=i(69117);let S=class extends((0,o.p)(n.Z)){constructor(t){super(t),this.availability=1,this.sources={multipoint:null,point:null,polygon:null,polyline:null},this.loadedWkids=new Set,this.loadedWkts=new Set,this.pendingAdds=[]}get updating(){return this.updatingHandles.updating}get layer(){return this.layerSource.layer}destroy(){const t=this.pendingAdds;this.pendingAdds.length=0;for(const e of t)e.task.abort();this._mapSources((t=>this._destroySource(t)))}initialize(){this.handles.add([this.layer.on("graphic-update",(t=>this._onGraphicUpdate(t))),this.updatingHandles.addOnCollectionChange((()=>this.layer.graphics),(t=>this._onGraphicsChanged(t)))]),this._addMany(this.layer.graphics.toArray())}async fetchCandidates(t,e){const i=(await(0,a.WW)(this._mapSources((i=>i.queryEngine.executeQueryForSnapping({point:t.coordinateHelper.vectorToPoint(t.point).toJSON(),distance:t.distance,types:t.types,query:(0,h.pC)(t.filter)?t.filter.createQuery().toJSON():{where:"1=1"}},e).then((t=>{let{candidates:e}=t;return e})))))).flat().map((e=>(0,v.X)(e,t.coordinateHelper,t.elevationInfo)));return(0,g.lQ)(t.point,i),i}refresh(){}_onGraphicUpdate(t){switch(t.property){case"geometry":case"visible":this._remove(t.graphic),this._addMany([t.graphic])}}_onGraphicsChanged(t){for(const e of t.removed)this._remove(e);this._addMany(t.added)}_addMany(t){const e=[],i=new Map;for(const s of t)(0,h.Wi)(s.geometry)||(this._needsInitializeProjection(s.geometry.spatialReference)?(e.push(s.geometry.spatialReference),i.set(s.uid,s)):this._add(s));this._createPendingAdd(e,i)}_createPendingAdd(t,e){if(!t.length)return;const i=(0,a.vr)((async i=>{await(0,p.iQ)(t.map((t=>({source:t,dest:this.spatialReference}))),{signal:i}),this._markLoadedSpatialReferences(t);for(const[,t]of e)this._add(t)}));this.updatingHandles.addPromise(i.promise);const s={task:i,graphics:e},n=()=>(0,r.e$)(this.pendingAdds,s);i.promise.then(n,n),this.pendingAdds.push(s)}_markLoadedSpatialReferences(t){for(const e of t)null!=e.wkid&&this.loadedWkids.add(e.wkid),null!=e.wkt&&this.loadedWkts.add(e.wkt)}_add(t){if((0,h.Wi)(t.geometry)||!t.visible)return;let e=t.geometry;if("mesh"===e.type)return;"extent"===e.type&&(e=c.Z.fromExtent(e));const i=this._ensureSource(e.type);if((0,h.Wi)(i))return;const s=this._createOptimizedFeature(t.uid,e);(0,h.pC)(s)&&i.featureStore.add(s)}_needsInitializeProjection(t){return(null==t.wkid||!this.loadedWkids.has(t.wkid))&&(null==t.wkt||!this.loadedWkts.has(t.wkt))&&!(0,p.Up)(t,this.spatialReference)}_createOptimizedFeature(t,e){const i=(0,p.iV)((0,d.SR)(e),this.spatialReference);return i?new f.u_((0,x.GH)(i,!1,!1),{[w]:t},null,t):null}_ensureSource(t){const e=this.sources[t];if((0,h.pC)(e))return e;const i=this._createSource(t);return this.sources[t]=i,i}_createSource(t){const e=m.Mk.toJSON(t),i=new y.Z({geometryType:e,hasZ:!1,hasM:!1});return{featureStore:i,queryEngine:new _.q({featureStore:i,fields:[{name:w,type:"esriFieldTypeOID",alias:w}],geometryType:e,hasM:!1,hasZ:!1,objectIdField:w,spatialReference:this.spatialReference,scheduler:(0,h.pC)(this.view)&&"3d"===this.view.type?this.view.resourceController.scheduler:null}),type:t}}_remove(t){this._mapSources((e=>this._removeFromSource(e,t)));for(const e of this.pendingAdds)e.graphics.delete(t.uid),0===e.graphics.size&&e.task.abort()}_removeFromSource(t,e){const i=e.uid;t.featureStore.has(i)&&t.featureStore.removeById(e.uid)}_destroySource(t){t.queryEngine.destroy(),this.sources[t.type]=null}_mapSources(t){const{point:e,polygon:i,polyline:s,multipoint:n}=this.sources,r=[];return(0,h.pC)(e)&&r.push(t(e)),(0,h.pC)(i)&&r.push(t(i)),(0,h.pC)(s)&&r.push(t(s)),(0,h.pC)(n)&&r.push(t(n)),r}};(0,s._)([(0,u.Cb)({constructOnly:!0})],S.prototype,"spatialReference",void 0),(0,s._)([(0,u.Cb)({constructOnly:!0})],S.prototype,"layerSource",void 0),(0,s._)([(0,u.Cb)({constructOnly:!0})],S.prototype,"view",void 0),(0,s._)([(0,u.Cb)({readOnly:!0})],S.prototype,"updating",null),(0,s._)([(0,u.Cb)({readOnly:!0})],S.prototype,"availability",void 0),S=(0,s._)([(0,l.j)("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")],S);const w="OBJECTID"},69117:(t,e,i)=>{i.d(e,{X:()=>a});var s=i(95905),n=i(95122),r=i(75691),o=i(61309);class h extends r.a{constructor(t){super({...t,constraint:new n.Hk(t.coordinateHelper,t.targetPoint)})}get hints(){return[new o.n(this.targetPoint,this.elevationInfo)]}}function a(t,e,i){switch(t.type){case"edge":return new s.L({coordinateHelper:e,edgeStart:e.pointToVector(t.start),edgeEnd:e.pointToVector(t.end),targetPoint:e.pointToVector(t.target),objectId:t.objectId,elevationInfo:i});case"vertex":return new h({coordinateHelper:e,targetPoint:e.pointToVector(t.target),objectId:t.objectId,elevationInfo:i})}}},61309:(t,e,i)=>{i.d(e,{n:()=>r});var s=i(64674),n=i(55054);class r extends n.r{constructor(t,e){super(e),this.point=t}equals(t){return t instanceof r&&(0,s.Xv)(this.point,t.point)}}}}]);
//# sourceMappingURL=3518.654f81f5.chunk.js.map