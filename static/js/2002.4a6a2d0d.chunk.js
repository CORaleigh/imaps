"use strict";(globalThis.webpackChunkimaps=globalThis.webpackChunkimaps||[]).push([[2002],{35888:(e,t,n)=>{n.d(t,{d:()=>o});var r=n(16889);function o(e,t,n){const o=e.byteLength/(4*t),c=new Uint32Array(e,0,o*t);let f=new Uint32Array(o);const u=n?.minReduction??0,p=n?.originalIndices||null,h=p?p.length:0,g=n?.componentOffsets||null;let m=0;if(g)for(let r=0;r<g.length-1;r++){const e=g[r+1]-g[r];e>m&&(m=e)}else m=o;const d=Math.floor(1.1*m)+1;(null==l||l.length<2*d)&&(l=new Uint32Array((0,r.Sf)(2*d)));for(let r=0;r<2*d;r++)l[r]=0;let x=0;const y=!!g&&!!p,w=y?h:o,b=y?new Uint32Array(h):null,v=1.96;let A=0!==u?Math.ceil(4*v*v/(u*u)*u*(1-u)):w,C=1,F=g?g[1]:w;for(let r=0;r<w;r++){if(r===A){const e=1-x/r;if(e+v*Math.sqrt(e*(1-e)/r)<u)return null;A*=2}if(r===F){for(let e=0;e<2*d;e++)l[e]=0;if(p)for(let e=g[C-1];e<g[C];e++)b[e]=f[p[e]];F=g[++C]}const e=y?p[r]:r,n=e*t,o=a(c,n,t);let s=o%d,h=x;for(;0!==l[2*s+1];){if(l[2*s]===o){const e=l[2*s+1]-1;if(i(c,n,e*t,t)){h=f[e];break}}s++,s>=d&&(s-=d)}h===x&&(l[2*s]=o,l[2*s+1]=e+1,x++),f[e]=h}if(0!==u&&1-x/o<u)return null;if(y){for(let e=g[C-1];e<b.length;e++)b[e]=f[p[e]];f=b}const R=new Uint32Array(t*x);x=0;for(let r=0;r<w;r++)f[r]===x&&(s(c,(y?p[r]:r)*t,R,x*t,t),x++);if(p&&!y){const e=new Uint32Array(h);for(let t=0;t<e.length;t++)e[t]=f[p[t]];f=e}return{buffer:R.buffer,indices:f,uniqueCount:x}}function i(e,t,n,r){for(let o=0;o<r;o++)if(e[t+o]!==e[n+o])return!1;return!0}function s(e,t,n,r,o){for(let i=0;i<o;i++)n[r+i]=e[t+i]}function a(e,t,n){let r=0;for(let o=0;o<n;o++)r=e[t+o]+r|0,r=r+(r<<11)+(r>>>2)|0;return r>>>0}let l=null},91320:(e,t,n)=>{n.d(t,{Mk:()=>c,ZI:()=>r,bT:()=>l});var r,o,i=n(79347),s=n(69662),a=n(35888);function l(e){const t=c(e.rings,e.hasZ,r.CCW_IS_HOLE),n=[];let o=0,s=0;for(const r of t.polygons){const e=r.count,a=r.index,l=new Float64Array(t.position.buffer,3*a*t.position.BYTES_PER_ELEMENT,3*e),c=r.holeIndices.map((e=>e-a)),f=new Uint32Array((0,i.e)(l,c,3));n.push({position:l,faces:f}),o+=l.length,s+=f.length}const l=function(e,t,n){if(1===e.length)return e[0];const r=new Float64Array(t),o=new Uint32Array(n);let i=0,s=0,a=0;for(const l of e){for(let e=0;e<l.position.length;e++)r[i++]=l.position[e];for(let e=0;e<l.faces.length;e++)o[s++]=l.faces[e]+a;a=i/3}return{position:r,faces:o}}(n,o,s),f=(0,a.d)(l.position.buffer,6,{originalIndices:l.faces});return l.position=new Float64Array(f.buffer),l.faces=f.indices,l}function c(e,t,n){const o=e.length,i=new Array(o),s=new Array(o),a=new Array(o);let l=0,c=0,p=0,h=0;for(let r=0;r<o;++r)h+=e[r].length;const g=new Float64Array(3*h);let m=0;for(let d=o-1;d>=0;d--){const h=e[d],x=n===r.CCW_IS_HOLE&&u(h);if(x&&1!==o)i[l++]=h;else{let e=h.length;for(let t=0;t<l;++t)e+=i[t].length;const n={index:m,pathLengths:new Array(l+1),count:e,holeIndices:new Array(l)};n.pathLengths[0]=h.length,h.length>0&&(a[p++]={index:m,count:h.length}),m=x?f(h,h.length-1,-1,g,m,h.length,t):f(h,0,1,g,m,h.length,t);for(let r=0;r<l;++r){const e=i[r];n.holeIndices[r]=m,n.pathLengths[r+1]=e.length,e.length>0&&(a[p++]={index:m,count:e.length}),m=f(e,0,1,g,m,e.length,t)}l=0,n.count>0&&(s[c++]=n)}}for(let r=0;r<l;++r){const e=i[r];e.length>0&&(a[p++]={index:m,count:e.length}),m=f(e,0,1,g,m,e.length,t)}return c<o&&(s.length=c),p<o&&(a.length=p),{position:g,polygons:s,outlines:a}}function f(e,t,n,r,o,i,s){o*=3;for(let a=0;a<i;++a){const i=e[t];r[o++]=i[0],r[o++]=i[1],r[o++]=s?i[2]:0,t+=n}return o/3}function u(e){return!(0,s.bu)(e,!1,!1)}(o=r||(r={}))[o.NONE=0]="NONE",o[o.CCW_IS_HOLE=1]="CCW_IS_HOLE"},52002:(e,t,n)=>{n.r(t),n.d(t,{meshFeatureSetFromJSON:()=>Le});var r=n(52639),o=n(92026),i=n(53866),s=n(27366),a=n(10064),l=n(41691),c=n(54472),f=n(32718),u=n(67426),p=n(66978),h=n(94172),g=n(49861),m=(n(63780),n(93169),n(25243),n(69912)),d=n(71353),x=n(32238),y=n(7882),w=n(80885),b=n(45238),v=n(64995),A=n(76046),C=n(27474),F=n(91320),R=n(79803),M=n(26548),Z=n(57898);const E=f.Z.getLogger("esri.geometry.support.meshUtils.centerAt");function O(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=n?.origin??e.origin;(0,o.pC)(e.transform)?(null!=n?.geographic&&n.geographic!==e.transform.geographic&&E.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,i=t.hasZ&&n.hasZ?t.z-n.z:0,s=e.origin;e.origin=[s[0]+r,s[1]+o,s[2]+i]}(e.transform,t,r)):(0,M.h)(e.spatialReference,n)?function(e,t,n){const r=(0,Z.FF)(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:i,tangent:s}=(0,Z.iv)(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=s,e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=L,o=I;if((0,R.KC)(t,o,e.spatialReference)){if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,E.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else E.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,r)}const I=(0,d.c)(),L=(0,d.c)();var P=n(35995);function S(e){const t=(0,P.Yd)(e.url);return n=>{const r=(0,P.PF)(n,t,t),o=r?r.replace(/^ *\.\//,""):null;return e.files.get(o)??n}}async function T(e,t){return e instanceof Blob?U.fromBlob(e):"string"==typeof e?new U(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const i=await(0,p.WW)(e.map((async e=>({name:e.name,source:await T(e instanceof Blob?e:e.source,t)})))),s=[];for(const o of i)o&&((0,p.Hc)(t)?o.source.dispose():s.push(o));(0,p.k_)(t);for(const{name:a,source:l}of s)((0,o.Wi)(r)||/\.(gltf|glb)/i.test(a))&&(r=l.url),n.set(a,l.url),l.files&&l.files.forEach(((e,t)=>n.set(t,e)));if((0,o.Wi)(r))throw new a.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new U(r,(()=>s.forEach((e=>{let{source:t}=e;return t.dispose()}))),n)}(e,t):async function(e,t){const{default:r}=await(0,p.Hl)(Promise.resolve().then(n.bind(n,76200)),t),o="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await r(e,{responseType:"array-buffer"})).data))):e.multipart;return U.fromBlob(new Blob(o))}(e,t)}class U{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map;this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new U(t,(()=>URL.revokeObjectURL(t)))}}var z=n(22753),k=n(11873),D=n(81949),N=n(11186),_=n(92183),$=n(11700);const j=f.Z.getLogger("esri.geometry.support.meshUtils.offset");function B(e,t,n){e.vertexAttributes&&e.vertexAttributes.position&&((0,o.pC)(e.transform)?(null!=n?.geographic&&n.geographic!==e.transform.geographic&&j.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=(0,N.a)((0,d.c)(),n,t)}(e.transform,t)):(0,M.h)(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,i=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,a=new Float64Array(r.length),l=(0,o.pC)(i)?new Float32Array(i.length):null,c=(0,o.pC)(s)?new Float32Array(s.length):null,f=e.extent.center,u=G;(0,R.Bm)(n,[f.x,f.y,f.z],H,(0,_.rS)(n)),(0,z.f)(Y,H),(0,N.t)(u,t,Y),(0,$.XO)(r,n,a),(0,o.pC)(i)&&(0,$.Iz)(i,r,a,n,l),(0,o.pC)(s)&&(0,$.wi)(s,r,a,n,c),W(a,u),(0,$.To)(a,r,n),(0,o.pC)(i)&&(0,$.Yk)(l,r,a,n,i),(0,o.pC)(s)&&(0,$.M2)(c,r,a,n,s),e.vertexAttributesChanged()}(e,t):function(e,t){W(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t))}function W(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const G=(0,d.c)(),H=(0,D.c)(),Y=(0,k.c)();const q={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function K(e,t,n){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];V[0]=n[0],V[4]=n[1],V[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let t=0;t<3;t++)Q[t]=e.position[r+t];(0,N.t)(Q,Q,V);for(let t=0;t<3;t++)e.position[r+t]=Q[t]}if(n[0]!==n[1]||n[1]!==n[2]){V[0]=1/n[0],V[4]=1/n[1],V[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)Q[n]=e.normal[t+n];(0,N.t)(Q,Q,V),(0,N.n)(Q,Q);for(let n=0;n<3;n++)e.normal[t+n]=Q[n]}}}(e,n&&n.size);const{vertexAttributes:r,transform:o}=(0,Z.w1)(e,t,n);return{vertexAttributes:new C.Q({...r,uv:e.uv}),transform:o,components:[new v.Z({faces:e.faces,material:n&&n.material||null})],spatialReference:t.spatialReference}}const X={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},J={south:0,east:1,north:2,west:3,up:4,down:5},Q=(0,d.c)(),V=(0,k.c)();var ee=n(14226);const te=f.Z.getLogger("esri.geometry.support.meshUtils.rotate");function ne(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if((0,o.pC)(e.transform)){null!=n?.geographic&&n.geographic!==e.transform.geographic&&te.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=n?.origin??e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,N.s)(oe,n.x,n.y,n.z),o=(0,N.b)(oe,r,e.origin);e.applyLocalInverse(o,ie),e.rotation=(0,b.qC)(e.rotation,t,(0,b.Ue)()),e.applyLocalInverse(o,o),(0,N.b)(o,o,ie),e.translation=(0,N.a)((0,d.c)(),e.translation,o)}(e.transform,t,o)}else{const r=n?.origin??e.origin;(0,M.h)(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,i=(0,_.rS)(r),s=ce;(0,R.KC)(n,s,i)||(0,R.KC)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,f=new Float64Array(a.length),u=(0,o.pC)(l)?new Float32Array(l.length):null,p=(0,o.pC)(c)?new Float32Array(c.length):null;(0,R.Bm)(i,s,ae,i),(0,z.f)(le,ae);const h=se;(0,N.t)((0,b.ZZ)(se),(0,b.ZZ)(t),le),h[3]=t[3],(0,$.XO)(a,r,f),(0,o.pC)(l)&&(0,$.Iz)(l,a,f,r,u),(0,o.pC)(c)&&(0,$.wi)(c,a,f,r,p),re(f,h,3,s),(0,$.To)(f,a,r),(0,o.pC)(l)&&(re(u,h,3),(0,$.Yk)(u,a,f,r,l)),(0,o.pC)(c)&&(re(p,h,4),(0,$.M2)(p,a,f,r,c)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=ce;if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,te.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}re(e.vertexAttributes.position,t,3,r),re(e.vertexAttributes.normal,t,3),re(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}function re(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d.Z;if(!(0,o.Wi)(e)){(0,ee.d)(ae,(0,b.WH)(t),(0,b.ZZ)(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)oe[n]=e[t+n]-r[n];(0,N.m)(oe,oe,ae);for(let n=0;n<3;n++)e[t+n]=oe[n]+r[n]}}}const oe=(0,d.c)(),ie=(0,d.c)(),se=(0,b.Ue)(),ae=(0,D.c)(),le=(0,k.c)(),ce=(0,d.c)(),fe=f.Z.getLogger("esri.geometry.support.meshUtils.scale");function ue(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if((0,o.pC)(e.transform)){null!=n?.geographic&&n.geographic!==e.transform.geographic&&fe.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=n?.origin??e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,N.s)(he,n.x,n.y,n.z),o=(0,N.b)(he,r,e.origin);e.applyLocalInverse(o,ge);const i=(0,N.g)((0,d.c)(),e.scale,t);e.scale=i,e.applyLocalInverse(o,o),(0,N.b)(o,o,ge),e.translation=(0,N.a)((0,d.c)(),e.translation,o)}(e.transform,t,o)}else{const r=(0,M.h)(e.spatialReference,n),i=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,i=(0,_.rS)(r),s=me;(0,R.KC)(n,s,i)||(0,R.KC)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,f=new Float64Array(a.length),u=(0,o.pC)(l)?new Float32Array(l.length):null,p=(0,o.pC)(c)?new Float32Array(c.length):null;(0,$.XO)(a,r,f),(0,o.pC)(l)&&(0,$.Iz)(l,a,f,r,u),(0,o.pC)(c)&&(0,$.wi)(c,a,f,r,p),pe(f,t,s),(0,$.To)(f,a,r),(0,o.pC)(l)&&(0,$.Yk)(u,a,f,r,l),(0,o.pC)(c)&&(0,$.M2)(p,a,f,r,c),e.vertexAttributesChanged()}(e,t,i):function(e,t,n){const r=me;if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,fe.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}pe(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,i)}}function pe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d.Z;if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)he[t]=e[r+t]-n[t];(0,N.g)(he,he,t);for(let t=0;t<3;t++)e[r+t]=he[t]+n[t]}}const he=(0,d.c)(),ge=(0,d.c)(),me=(0,d.c)();var de;const xe=f.Z.getLogger("esri.geometry.Mesh");let ye=de=class extends((0,l.p)(c.Z.LoadableMixin((0,u.v)(x.Z)))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new C.Q,this.type="mesh"}initialize(){((0,o.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add((0,h.YP)((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone())),transform:(0,o.pC)(this.transform)?this.transform.clone():null})),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new i.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new y.Z({x:0,y:0,z:0,spatialReference:t})};const n=(0,o.pC)(this.transform)?this.transform.project(e,t):e;let r=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,f=-1/0,u=0,p=0,h=0;const g=n.length,m=1/(g/3);let d=0;for(;d<g;){const e=n[d++],t=n[d++],o=n[d++];r=Math.min(r,e),s=Math.min(s,t),a=Math.min(a,o),l=Math.max(l,e),c=Math.max(c,t),f=Math.max(f,o),u+=m*e,p+=m*t,h+=m*o}return{extent:new i.Z({xmin:r,ymin:s,zmin:a,xmax:l,ymax:c,zmax:f,spatialReference:t}),center:new y.Z({x:u,y:p,z:h,spatialReference:t})}}get anchor(){if((0,o.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new y.Z({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,o.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(v.Z.from(e)),this.notifyChange("components")):xe.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}xe.error("removeComponent()","Provided component is not part of the list of components")}else xe.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return(0,b.uT)(we.x,e,be),(0,b.uT)(we.y,t,ve),(0,b.uT)(we.z,n,Ae),(0,b.qC)(be,ve,be),(0,b.qC)(be,Ae,be),ne(this,be,r),this}offset(e,t,n,r){return this.loaded?(Ce[0]=e,Ce[1]=t,Ce[2]=n,B(this,Ce,r),this):(xe.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(ue(this,e,t),this):(xe.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(O(this,e,t),this):(xe.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return(0,o.pC)(this.external)&&this.addResolvingPromise(async function(e,t,r){const{loadGLTFMesh:i}=await(0,p.Hl)(Promise.all([n.e(493),n.e(8596)]).then(n.bind(n,35886)),r),s=await T(t,r),a=i(new y.Z({x:0,y:0,z:0,spatialReference:e.spatialReference}),s.url,{resolveFile:S(s),useTransform:!0,signal:(0,o.pC)(r)?r.signal:null});a.then((()=>s.dispose()),(()=>s.dispose()));const{vertexAttributes:l,components:c}=await a;e.vertexAttributes=l,e.components=c}(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,t=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(e,t))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,o.pC)(this.transform)?this.transform.clone():null,external:(0,o.pC)(this.external)?{source:this.external.source,extent:(0,o.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new de(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:t}=await n.e(5477).then(n.bind(n,95477));return t(this,e)}static createBox(e,t){if(!(e instanceof y.Z))return xe.error(".createBox()","expected location to be a Point instance"),null;const n=new de(K(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=X,r=4*e.length,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,f=0,u=0;for(let p=0;p<e.length;p++){const r=e[p],h=l/3;for(const e of t)a[u++]=h+e;const g=r.corners;for(let e=0;e<4;e++){const t=g[e];let a=0;s[f++]=.25*n[e][0]+r.uvOrigin[0],s[f++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[l++]=.5*r.axis[e],i[c++]=r.axis[e]):(o[l++]=.5*t[a++],i[c++]=0)}}return{position:o,normal:i,uv:s,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,i=J[t],s=6*i,a=new Uint32Array(6),l=new Uint32Array(r.length-6);let c=0,f=0;for(let o=0;o<r.length;o++)o>=s&&o<s+6?a[c++]=r[o]:l[f++]=r[o];if((0,o.pC)(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*i*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new v.Z({faces:a,material:n.material}),new v.Z({faces:l})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof y.Z?new de(K(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array((t-1)*n*2*3);let l=0,c=0,f=0,u=0;for(let p=0;p<=t;p++){const e=p/t*Math.PI+.5*Math.PI,r=Math.cos(e),h=Math.sin(e);Q[2]=h;const g=0===p||p===t,m=g?n-1:n;for(let d=0;d<=m;d++){const e=d/m*2*Math.PI;Q[0]=-Math.sin(e)*r,Q[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[l]=.5*Q[t],i[l]=Q[t],++l;s[c++]=(d+(g?.5:0))/n,s[c++]=p/t,0!==p&&d!==n&&(p!==t&&(a[f++]=u,a[f++]=u+1,a[f++]=u-n),1!==p&&(a[f++]=u,a[f++]=u-n,a[f++]=u-n-1)),u++}}return{position:o,normal:i,uv:s,faces:a}}(t&&t.densificationFactor||0),e,t)):(xe.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof y.Z?new de(K(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=5,n=Math.round(16*2**e),r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(4*n*3);let l=0,c=0,f=0,u=0,p=0;for(let h=0;h<=t;h++){const e=0===h||h===t,r=h<=1||h>=t-1,g=2===h||4===h,m=e?n-1:n;for(let d=0;d<=m;d++){const x=d/m*2*Math.PI,y=e?0:.5;Q[0]=y*Math.sin(x),Q[1]=y*-Math.cos(x),Q[2]=h<=2?.5:-.5;for(let e=0;e<3;e++)o[l++]=Q[e],i[c++]=r?2===e?h<=1?1:-1:0:2===e?0:Q[e]/y;s[f++]=(d+(e?.5:0))/n,s[f++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,g||0===h||d===n||(h!==t&&(a[u++]=p,a[u++]=p+1,a[u++]=p-n),1!==h&&(a[u++]=p,a[u++]=p-n,a[u++]=p-n-1)),p++}}return{position:o,normal:i,uv:s,faces:a}}(t&&t.densificationFactor||0),e,t)):(xe.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){if(!(e instanceof y.Z))return xe.error(".createPlane()","expected location to be a Point instance"),null;const n=t?.facing??"up",r=function(e,t){const n="number"==typeof t?t:null!=t?t.width:1,r="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}(n,t?.size);return new de(K(function(e){const t=q.facingAxisOrderSwap[e],n=q.position,r=q.normal,o=new Float64Array(n.length),i=new Float32Array(r.length);let s=0;for(let a=0;a<4;a++){const e=s;for(let a=0;a<3;a++){const l=t[a],c=Math.abs(l)-1,f=l>=0?1:-1;o[s]=n[e+c]*f,i[s]=r[e+c]*f,s++}}return{position:o,normal:i,uv:new Float32Array(q.uv),faces:new Uint32Array(q.faces),isPlane:!0}}(n),e,{...t,size:r}))}static createFromPolygon(e,t){if(!(e instanceof w.Z))return xe.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=(0,F.bT)(e);return new de({vertexAttributes:new C.Q({position:n.position}),components:[new v.Z({faces:n.faces,shading:"flat",material:t&&t.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,r){if(!(e instanceof y.Z))throw xe.error(".createfromGLTF()","expected location to be a Point instance"),new a.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await(0,p.Hl)(Promise.all([n.e(493),n.e(8596)]).then(n.bind(n,35886)),r);return new de(await o(e,t,r))}static createWithExternalSource(e,t,n){const r=n?.extent??null,o=n?.transform.clone()??new A.Z;o.origin=[e.x,e.y,e.z??0];const i=e.spatialReference;return new de({external:{source:t,extent:r},transform:o,spatialReference:i})}static createIncomplete(e,t){const n=t?.transform.clone()??new A.Z;n.origin=[e.x,e.y,e.z??0];const r=e.spatialReference,o=new de({transform:n,spatialReference:r});return o.addResolvingPromise(Promise.reject(new a.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,s._)([(0,g.Cb)({type:[v.Z],json:{write:!0}})],ye.prototype,"components",void 0),(0,s._)([(0,g.Cb)({type:A.Z,json:{write:!0}})],ye.prototype,"transform",void 0),(0,s._)([(0,g.Cb)({constructOnly:!0})],ye.prototype,"external",void 0),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"hasExtent",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"boundingInfo",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"anchor",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"origin",null),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1}})],ye.prototype,"extent",null),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],ye.prototype,"hasZ",void 0),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],ye.prototype,"hasM",void 0),(0,s._)([(0,g.Cb)({type:C.Q,nonNullable:!0,json:{write:!0}})],ye.prototype,"vertexAttributes",void 0),ye=de=(0,s._)([(0,m.j)("esri.geometry.Mesh")],ye);const we={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},be=(0,b.Ue)(),ve=(0,b.Ue)(),Ae=(0,b.Ue)(),Ce=(0,d.c)(),Fe=ye;var Re,Me,Ze;(Ze=Re||(Re={})).featureGUID="featureGUID",Ze.assetName="assetName",Ze.hash="hash",Ze.type="type",Ze.conversionStatus="conversionStatus",Ze.flags="flags",Ze.complexity="complexity",Ze.size="size",Ze.seqNo="seqNo",Ze.sourceHash="sourceHash",Ze.assetURL="assetURL",function(e){e.SUBMITTED="SUBMITTED",e.INPROGRESS="INPROGRESS",e.FAILED="FAILED",e.COMPLETED="COMPLETED"}(Me||(Me={}));var Ee,Oe,Ie=n(49818);function Le(e,t,n){const i=n.features;n.features=[],delete n.geometryType;const s=Ie.default.fromJSON(n);s.geometryType="mesh";const a=s.spatialReference,l=(0,o.Wi)(e.outFields)||!e.outFields.length?()=>({}):(c=e.outFields.includes("*")?null:new Set(e.outFields),e=>{let{attributes:t}=e;if(!t)return{};if(!c)return t;for(const n in t)c.has(n)||delete t[n];return t});var c;for(const f of i){const e=Pe(f,a,t);(0,o.pC)(e)&&s.features.push(new r.Z({geometry:e,attributes:l(f)}))}return s}function Pe(e,t,n){const{status:r,source:o}=function(e){if(!e.assetMappings)return{status:Ee.FAILED};const t=[],n=new Map;for(const r of e.assetMappings){const e=r[Re.seqNo],o=r[Re.assetName],i=r[Re.assetURL],s=r[Re.conversionStatus];if(s===Me.FAILED)return{status:Ee.FAILED};if(s!==Me.COMPLETED)return{status:Ee.PENDING};if(null==e)t.push({name:o,source:i});else{const r=n.get(o);let s;r?s=r.multipart:(s=[],t.push({name:o,source:{multipart:s}}),n.set(o,{multipart:s})),s[e]=i}}return{status:Ee.COMPLETED,source:t}}(e);if(r===Ee.FAILED)return null;const s=function(e,t,n){let{attributes:r}=e,{transformFieldRoles:o}=n;return new y.Z({x:r[o.originX],y:r[o.originY],z:r[o.originZ],spatialReference:t})}(e,t,n),a=i.Z.fromJSON(e.geometry);a.spatialReference=t;const l=function(e,t){let{attributes:n,assetMappings:r}=e,{transformFieldRoles:o}=t;return new A.Z({translation:[n[o.translationX],n[o.translationY],n[o.translationZ]],rotation:(0,b.uT)([n[o.rotationX],n[o.rotationY],n[o.rotationZ]],n[o.rotationDeg]),scale:[n[o.scaleX],n[o.scaleY],n[o.scaleZ]],geographic:!r[Re.flags]?.includes("PROJECT_VERTICES")})}(e,n);return r===Ee.PENDING?Fe.createIncomplete(s,{extent:a,transform:l}):Fe.createWithExternalSource(s,o,{extent:a,transform:l})}(Oe=Ee||(Ee={}))[Oe.FAILED=0]="FAILED",Oe[Oe.PENDING=1]="PENDING",Oe[Oe.COMPLETED=2]="COMPLETED"}}]);
//# sourceMappingURL=2002.4a6a2d0d.chunk.js.map