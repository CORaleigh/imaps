"use strict";(globalThis.webpackChunkimaps=globalThis.webpackChunkimaps||[]).push([[2348],{45957:(e,t,n)=>{n.r(t),n.d(t,{meshFeatureSetFromJSON:()=>Pe});var r=n(52639),o=n(92026),i=n(53866),s=n(27366),a=n(10064),l=n(41691),c=n(54472),f=n(32718),u=n(67426),p=n(66978),h=n(94172),g=n(49861),m=(n(25243),n(63780),n(69912)),d=n(71353),y=n(32238),x=n(585),w=n(80885),b=n(45238),A=n(64995),v=n(76046),C=n(27474),Z=n(91320),R=n(79803),F=n(26548),M=n(57898);const P=f.Z.getLogger("esri.geometry.support.meshUtils.centerAt");function L(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=n?.origin??e.origin;(0,o.pC)(e.transform)?(null!=n?.geographic&&n.geographic!==e.transform.geographic&&P.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,i=t.hasZ&&n.hasZ?t.z-n.z:0,s=e.origin;e.origin=[s[0]+r,s[1]+o,s[2]+i]}(e.transform,t,r)):(0,F.h)(e.spatialReference,n)?function(e,t,n){const r=(0,M.FF)(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:i,tangent:s}=(0,M.iv)(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=s,e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=O,o=E;if((0,R.KC)(t,o,e.spatialReference)){if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,P.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else P.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,r)}const E=(0,d.c)(),O=(0,d.c)();var U=n(35995);function I(e){const t=(0,U.Yd)(e.url);return n=>{const r=(0,U.PF)(n,t,t),o=r?r.replace(/^ *\.\//,""):null;return(o?e.files.get(o):null)??n}}async function T(e,t){return e instanceof Blob?z.fromBlob(e):"string"==typeof e?new z(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const i=await(0,p.WW)(e.map((async e=>({name:e.name,source:await T(e instanceof Blob?e:e.source,t)})))),s=[];for(const o of i)o&&((0,p.Hc)(t)?o.source.dispose():s.push(o));(0,p.k_)(t);for(const{name:a,source:l}of s)((0,o.Wi)(r)||/\.(gltf|glb)/i.test(a))&&(r=l.url),n.set(a,l.url),l.files&&l.files.forEach(((e,t)=>n.set(t,e)));if((0,o.Wi)(r))throw new a.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new z(r,(()=>s.forEach((e=>{let{source:t}=e;return t.dispose()}))),n)}(e,t):async function(e,t){const{default:r}=await(0,p.Hl)(Promise.resolve().then(n.bind(n,76200)),t),o="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await r(e,{responseType:"array-buffer"})).data))):e.multipart;return z.fromBlob(new Blob(o))}(e,t)}class z{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map;this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new z(t,(()=>URL.revokeObjectURL(t)))}}var S=n(22753),k=n(11873),D=n(81949),_=n(11186),B=n(29691),j=n(11700);function N(e,t,n){var r,i;e.vertexAttributes&&e.vertexAttributes.position&&((0,o.pC)(e.transform)?(null!=n?.geographic&&n.geographic!==e.transform.geographic&&f.Z.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=(0,_.a)((0,d.c)(),n,t)}(e.transform,t)):(0,F.h)(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,i=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,a=new Float64Array(r.length),l=(0,o.pC)(i)?new Float32Array(i.length):null,c=(0,o.pC)(s)?new Float32Array(s.length):null,f=e.extent.center,u=G;(0,R.Bm)(n,[f.x,f.y,f.z],W,(0,B.rS)(n)),(0,S.f)(Y,W),(0,_.t)(u,t,Y),(0,j.XO)(r,n,a),(0,o.pC)(i)&&(0,o.pC)(l)&&(0,j.Iz)(i,r,a,n,l),(0,o.pC)(s)&&(0,o.pC)(c)&&(0,j.wi)(s,r,a,n,c),$(a,u),(0,j.To)(a,r,n),(0,o.pC)(i)&&(0,o.pC)(l)&&(0,j.Yk)(l,r,a,n,i),(0,o.pC)(s)&&(0,o.pC)(c)&&(0,j.M2)(c,r,a,n,s),e.vertexAttributesChanged()}(e,t):(i=t,$((r=e).vertexAttributes.position,i),r.vertexAttributesChanged()))}function $(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const G=(0,d.c)(),W=(0,D.c)(),Y=(0,k.c)();const K={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function X(e,t,n){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];q[0]=n[0],q[4]=n[1],q[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let t=0;t<3;t++)Q[t]=e.position[r+t];(0,_.t)(Q,Q,q);for(let t=0;t<3;t++)e.position[r+t]=Q[t]}if(n[0]!==n[1]||n[1]!==n[2]){q[0]=1/n[0],q[4]=1/n[1],q[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)Q[n]=e.normal[t+n];(0,_.t)(Q,Q,q),(0,_.n)(Q,Q);for(let n=0;n<3;n++)e.normal[t+n]=Q[n]}}}(e,n?.size);const{vertexAttributes:r,transform:o}=(0,M.w1)(e,t,n);return{vertexAttributes:new C.Q({...r,uv:e.uv}),transform:o,components:[new A.Z({faces:e.faces,material:n&&n.material||null})],spatialReference:t.spatialReference}}const V={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},H={south:0,east:1,north:2,west:3,up:4,down:5},Q=(0,d.c)(),q=(0,k.c)();var J=n(14226);const ee=f.Z.getLogger("esri.geometry.support.meshUtils.rotate");function te(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if((0,o.pC)(e.transform)){null!=n?.geographic&&n.geographic!==e.transform.geographic&&ee.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=n?.origin??e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,_.s)(re,n.x,n.y,n.z),o=(0,_.b)(re,r,e.origin);e.applyLocalInverse(o,oe),e.rotation=(0,b.qC)(e.rotation,t,(0,b.Ue)()),e.applyLocalInverse(o,o),(0,_.b)(o,o,oe),e.translation=(0,_.a)((0,d.c)(),e.translation,o)}(e.transform,t,o)}else{const r=n?.origin??e.origin;(0,F.h)(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,i=(0,B.rS)(r),s=le;(0,R.KC)(n,s,i)||(0,R.KC)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,f=new Float64Array(a.length),u=(0,o.pC)(l)?new Float32Array(l.length):null,p=(0,o.pC)(c)?new Float32Array(c.length):null;(0,R.Bm)(i,s,se,i),(0,S.f)(ae,se);const h=ie;(0,_.t)((0,b.ZZ)(ie),(0,b.ZZ)(t),ae),h[3]=t[3],(0,j.XO)(a,r,f),(0,o.pC)(l)&&(0,o.pC)(u)&&(0,j.Iz)(l,a,f,r,u),(0,o.pC)(c)&&(0,o.pC)(p)&&(0,j.wi)(c,a,f,r,p),ne(f,h,3,s),(0,j.To)(f,a,r),(0,o.pC)(l)&&(0,o.pC)(u)&&(ne(u,h,3),(0,j.Yk)(u,a,f,r,l)),(0,o.pC)(c)&&(0,o.pC)(p)&&(ne(p,h,4),(0,j.M2)(p,a,f,r,c)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=le;if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,ee.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}ne(e.vertexAttributes.position,t,3,r),ne(e.vertexAttributes.normal,t,3),ne(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}function ne(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d.Z;if(!(0,o.Wi)(e)){(0,J.d)(se,(0,b.WH)(t),(0,b.ZZ)(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)re[n]=e[t+n]-r[n];(0,_.m)(re,re,se);for(let n=0;n<3;n++)e[t+n]=re[n]+r[n]}}}const re=(0,d.c)(),oe=(0,d.c)(),ie=(0,b.Ue)(),se=(0,D.c)(),ae=(0,k.c)(),le=(0,d.c)(),ce=f.Z.getLogger("esri.geometry.support.meshUtils.scale");function fe(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if((0,o.pC)(e.transform)){null!=n?.geographic&&n.geographic!==e.transform.geographic&&ce.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=n?.origin??e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,_.s)(pe,n.x,n.y,n.z),o=(0,_.b)(pe,r,e.origin);e.applyLocalInverse(o,he);const i=(0,_.g)((0,d.c)(),e.scale,t);e.scale=i,e.applyLocalInverse(o,o),(0,_.b)(o,o,he),e.translation=(0,_.a)((0,d.c)(),e.translation,o)}(e.transform,t,o)}else{const r=(0,F.h)(e.spatialReference,n),i=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,i=(0,B.rS)(r),s=ge;(0,R.KC)(n,s,i)||(0,R.KC)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,f=new Float64Array(a.length),u=(0,o.pC)(l)?new Float32Array(l.length):null,p=(0,o.pC)(c)?new Float32Array(c.length):null;(0,j.XO)(a,r,f),(0,o.pC)(l)&&(0,o.pC)(u)&&(0,j.Iz)(l,a,f,r,u),(0,o.pC)(c)&&(0,o.pC)(p)&&(0,j.wi)(c,a,f,r,p),ue(f,t,s),(0,j.To)(f,a,r),(0,o.pC)(l)&&(0,o.pC)(u)&&(0,j.Yk)(u,a,f,r,l),(0,o.pC)(c)&&(0,o.pC)(p)&&(0,j.M2)(p,a,f,r,c),e.vertexAttributesChanged()}(e,t,i):function(e,t,n){const r=ge;if(!(0,R.KC)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,ce.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}ue(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,i)}}function ue(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d.Z;if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)pe[t]=e[r+t]-n[t];(0,_.g)(pe,pe,t);for(let t=0;t<3;t++)e[r+t]=pe[t]+n[t]}}const pe=(0,d.c)(),he=(0,d.c)(),ge=(0,d.c)();var me;const de="esri.geometry.Mesh";let ye=me=class extends((0,l.p)(c.Z.LoadableMixin((0,u.v)(y.Z)))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new C.Q,this.type="mesh"}initialize(){((0,o.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add((0,h.YP)((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new i.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new x.Z({x:0,y:0,z:0,spatialReference:t})};const n=(0,o.pC)(this.transform)?this.transform.project(e,t):e;let r=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,f=-1/0,u=0,p=0,h=0;const g=n.length,m=1/(g/3);let d=0;for(;d<g;){const e=n[d++],t=n[d++],o=n[d++];r=Math.min(r,e),s=Math.min(s,t),a=Math.min(a,o),l=Math.max(l,e),c=Math.max(c,t),f=Math.max(f,o),u+=m*e,p+=m*t,h+=m*o}return{extent:new i.Z({xmin:r,ymin:s,zmin:a,xmax:l,ymax:c,zmax:f,spatialReference:t}),center:new x.Z({x:u,y:p,z:h,spatialReference:t})}}get anchor(){if((0,o.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new x.Z({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,o.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(A.Z.from(e)),this.notifyChange("components")):f.Z.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}f.Z.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else f.Z.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return(0,b.uT)(xe.x,e,we),(0,b.uT)(xe.y,t,be),(0,b.uT)(xe.z,n,Ae),(0,b.qC)(we,be,we),(0,b.qC)(we,Ae,we),te(this,we,r),this}offset(e,t,n,r){return this.loaded?(ve[0]=e,ve[1]=t,ve[2]=n,N(this,ve,r),this):(f.Z.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(fe(this,e,t),this):(f.Z.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(L(this,e,t),this):(f.Z.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return(0,o.pC)(this.external)&&this.addResolvingPromise(async function(e,t,r){const{loadGLTFMesh:i}=await(0,p.Hl)(Promise.all([n.e(9900),n.e(6782)]).then(n.bind(n,35886)),r),s=await T(t,r),a=i(new x.Z({x:0,y:0,z:0,spatialReference:e.spatialReference}),s.url,{resolveFile:I(s),useTransform:!0,signal:(0,o.pC)(r)?r.signal:null});a.then((()=>s.dispose()),(()=>s.dispose()));const{vertexAttributes:l,components:c}=await a;e.vertexAttributes=l,e.components=c}(this,this.external.source,e)),Promise.resolve(this)}updateExternalSource(e){this._set("external",e)}clone(){let e=null;if(this.components){const t=new Map,n=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,n)))}const t={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,o.pC)(this.transform)?this.transform.clone():null,external:(0,o.pC)(this.external)?{source:this.external.source,extent:(0,o.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new me(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=n.e(5477).then(n.bind(n,95477)),r=this.load(),o=await Promise.all([t,r]),{toBinaryGLTF:i}=o[0];return i(this,e)}static createBox(e,t){if(!(e instanceof x.Z))return f.Z.getLogger(de).error(".createBox()","expected location to be a Point instance"),null;const n=new me(X(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=V,r=4*e.length,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,f=0,u=0;for(let p=0;p<e.length;p++){const r=e[p],h=l/3;for(const e of t)a[u++]=h+e;const g=r.corners;for(let e=0;e<4;e++){const t=g[e];let a=0;s[f++]=.25*n[e][0]+r.uvOrigin[0],s[f++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[l++]=.5*r.axis[e],i[c++]=r.axis[e]):(o[l++]=.5*t[a++],i[c++]=0)}}return{position:o,normal:i,uv:s,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,i=H[t],s=6*i,a=new Array(6),l=new Array(r.length-6);let c=0,f=0;for(let o=0;o<r.length;o++)o>=s&&o<s+6?a[c++]=r[o]:l[f++]=r[o];if((0,o.pC)(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*i*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new A.Z({faces:a,material:n.material}),new A.Z({faces:l})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof x.Z?new me(X(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array((t-1)*n*2*3);let l=0,c=0,f=0,u=0;for(let p=0;p<=t;p++){const e=p/t*Math.PI+.5*Math.PI,r=Math.cos(e),h=Math.sin(e);Q[2]=h;const g=0===p||p===t,m=g?n-1:n;for(let d=0;d<=m;d++){const e=d/m*2*Math.PI;Q[0]=-Math.sin(e)*r,Q[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[l]=.5*Q[t],i[l]=Q[t],++l;s[c++]=(d+(g?.5:0))/n,s[c++]=p/t,0!==p&&d!==n&&(p!==t&&(a[f++]=u,a[f++]=u+1,a[f++]=u-n),1!==p&&(a[f++]=u,a[f++]=u-n,a[f++]=u-n-1)),u++}}return{position:o,normal:i,uv:s,faces:a}}(t&&t.densificationFactor||0),e,t)):(f.Z.getLogger(de).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof x.Z?new me(X(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=5,n=Math.round(16*2**e),r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(4*n*3);let l=0,c=0,f=0,u=0,p=0;for(let h=0;h<=t;h++){const e=0===h||h===t,r=h<=1||h>=t-1,g=2===h||4===h,m=e?n-1:n;for(let d=0;d<=m;d++){const y=d/m*2*Math.PI,x=e?0:.5;Q[0]=x*Math.sin(y),Q[1]=x*-Math.cos(y),Q[2]=h<=2?.5:-.5;for(let e=0;e<3;e++)o[l++]=Q[e],i[c++]=r?2===e?h<=1?1:-1:0:2===e?0:Q[e]/x;s[f++]=(d+(e?.5:0))/n,s[f++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,g||0===h||d===n||(h!==t&&(a[u++]=p,a[u++]=p+1,a[u++]=p-n),1!==h&&(a[u++]=p,a[u++]=p-n,a[u++]=p-n-1)),p++}}return{position:o,normal:i,uv:s,faces:a}}(t&&t.densificationFactor||0),e,t)):(f.Z.getLogger(de).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){if(!(e instanceof x.Z))return f.Z.getLogger(de).error(".createPlane()","expected location to be a Point instance"),null;const n=t?.facing??"up",r=function(e,t){const n="number"==typeof t?t:null!=t?t.width:1,r="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}(n,t?.size);return new me(X(function(e){const t=K.facingAxisOrderSwap[e],n=K.position,r=K.normal,o=new Float64Array(n.length),i=new Float32Array(r.length);let s=0;for(let a=0;a<4;a++){const e=s;for(let a=0;a<3;a++){const l=t[a],c=Math.abs(l)-1,f=l>=0?1:-1;o[s]=n[e+c]*f,i[s]=r[e+c]*f,s++}}return{position:o,normal:i,uv:new Float32Array(K.uv),faces:new Uint32Array(K.faces),isPlane:!0}}(n),e,{...t,size:r}))}static createFromPolygon(e,t){if(!(e instanceof w.Z))return f.Z.getLogger(de).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=(0,Z.bT)(e);return new me({vertexAttributes:new C.Q({position:n.position}),components:[new A.Z({faces:n.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,r){if(!(e instanceof x.Z))throw f.Z.getLogger(de).error(".createfromGLTF()","expected location to be a Point instance"),new a.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await(0,p.Hl)(Promise.all([n.e(9900),n.e(6782)]).then(n.bind(n,35886)),r);return new me(await o(e,t,r))}static createWithExternalSource(e,t,n){const r=n?.extent??null,o=n?.transform?.clone()??new v.Z;o.origin=[e.x,e.y,e.z??0];const i=e.spatialReference;return new me({external:{source:t,extent:r},transform:o,spatialReference:i})}static createIncomplete(e,t){const n=t?.transform?.clone()??new v.Z;n.origin=[e.x,e.y,e.z??0];const r=e.spatialReference,o=new me({transform:n,spatialReference:r});return o.addResolvingPromise(Promise.reject(new a.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,s._)([(0,g.Cb)({type:[A.Z],json:{write:!0}})],ye.prototype,"components",void 0),(0,s._)([(0,g.Cb)({type:v.Z,json:{write:!0}})],ye.prototype,"transform",void 0),(0,s._)([(0,g.Cb)({constructOnly:!0})],ye.prototype,"external",void 0),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"hasExtent",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"_boundingInfo",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"anchor",null),(0,s._)([(0,g.Cb)({readOnly:!0})],ye.prototype,"origin",null),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1}})],ye.prototype,"extent",null),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],ye.prototype,"hasZ",void 0),(0,s._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],ye.prototype,"hasM",void 0),(0,s._)([(0,g.Cb)({type:C.Q,nonNullable:!0,json:{write:!0}})],ye.prototype,"vertexAttributes",void 0),ye=me=(0,s._)([(0,m.j)(de)],ye);const xe={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},we=(0,b.Ue)(),be=(0,b.Ue)(),Ae=(0,b.Ue)(),ve=(0,d.c)(),Ce=ye;var Ze,Re,Fe=n(78952),Me=n(49818);function Pe(e,t,n){const i=n.features;n.features=[],delete n.geometryType;const s=Me.Z.fromJSON(n);if(s.geometryType="mesh",!n.assetMaps)return s;const a=function(e,t){const n=new Map;for(const r of t){const e=r.parentGlobalId;if(null==e)continue;const t=r.assetName,o=r.assetURL,i=r.conversionStatus;let s=n.get(e);if(null==s)switch(s={name:t,status:Ze.FAILED,url:o,projectVertices:Ee(r.flags).projectVertices},n.set(e,s),i){case"COMPLETED":case"SUBMITTED":s.status=Ze.COMPLETED;break;case"INPROGRESS":s.status=Ze.PENDING;break;default:s.status=Ze.FAILED}else console.warn(`Multiple asset parts not expected. Ignoring additional parts. conflicting assetname: ${r.assetName}`)}return n}(0,n.assetMaps),l=s.spatialReference??Fe.Z.WGS84,c=n.globalIdFieldName,{outFields:f}=e,u=(0,o.pC)(f)&&f.length>0?(p=f.includes("*")?null:new Set(f),e=>{let{attributes:t}=e;if(!t)return{};if(!p)return t;for(const n in t)p.has(n)||delete t[n];return t}):()=>({});var p;for(const h of i){const e=Le(h,c,l,t,a);(0,o.pC)(e)&&s.features.push(new r.Z({geometry:e,attributes:u(h)}))}return s}function Le(e,t,n,r,o){const s=e.attributes[t],a=o.get(s);if(null==a||a.status===Ze.FAILED||null==a.url)return null;const l=function(e,t,n){let{attributes:r}=e,{transformFieldRoles:o}=n;return new x.Z({x:r[o.originX],y:r[o.originY],z:r[o.originZ],spatialReference:t})}(e,n,r),c=i.Z.fromJSON(e.geometry);c.spatialReference=n;const f=function(e,t,n){let{transformFieldRoles:r}=t;return new v.Z({translation:[e[r.translationX],-e[r.translationZ],e[r.translationY]],rotation:(0,b.uT)([e[r.rotationX],e[r.rotationZ],e[r.rotationY]],e[r.rotationDeg]),scale:[e[r.scaleX],e[r.scaleY],e[r.scaleZ]],geographic:n})}(e.attributes,r,a.projectVertices);return a.status===Ze.PENDING?Ce.createIncomplete(l,{extent:c,transform:f}):Ce.createWithExternalSource(l,[{name:a.name,source:a.url}],{extent:c,transform:f})}function Ee(e){return{projectVertices:e.includes("PROJECT_VERTICES")}}(Re=Ze||(Ze={}))[Re.FAILED=0]="FAILED",Re[Re.PENDING=1]="PENDING",Re[Re.COMPLETED=2]="COMPLETED"},88699:(e,t,n)=>{n.d(t,{QZ:()=>i,Rq:()=>s,bg:()=>o});var r=n(18722);function o(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e<=r.DB?t?new Array(e).fill(0):new Array(e):new Float64Array(e)}function i(e){return length<=r.DB?Array.from(e):new Float64Array(e)}function s(e,t,n){return Array.isArray(e)?e.slice(t,t+n):e.subarray(t,t+n)}},72838:(e,t,n)=>{n.d(t,{$z:()=>i,DX:()=>f,mi:()=>o,p:()=>c});var r=n(18722);function o(e){if(Array.isArray(e)){if(e.length<r.DB)return e;for(const t of e)if(t>=65536)return new Uint32Array(e);return new Uint16Array(e)}if(e.length<r.DB)return Array.from(e);if(e.BYTES_PER_ELEMENT===Uint16Array.BYTES_PER_ELEMENT)return e;for(const t of e)if(t>=65536)return e;return new Uint16Array(e)}function i(e){const t=3*e;return t<=r.DB?new Array(t):t<=65536?new Uint16Array(t):new Uint32Array(t)}let s=(()=>{const e=new Uint32Array(131072);for(let t=0;t<e.length;++t)e[t]=t;return e})();const a=[0],l=(()=>{const e=new Uint16Array(65536);for(let t=0;t<e.length;++t)e[t]=t;return e})();function c(e){if(1===e)return a;if(e<r.DB)return Array.from(new Uint16Array(l.buffer,0,e));if(e<l.length)return new Uint16Array(l.buffer,0,e);if(e>s.length){const t=Math.max(2*s.length,e);s=new Uint32Array(t);for(let e=0;e<s.length;e++)s[e]=e}return new Uint32Array(s.buffer,0,e)}function f(e){if(1===e)return a;if(e<r.DB)return Array.from(new Uint16Array(l.buffer,0,e));if(e<l.length)return new Uint16Array(l.slice(0,e));if(e>s.length){const t=new Uint32Array(e);for(let e=0;e<t.length;e++)t[e]=e;return t}return new Uint32Array(s.slice(0,e))}}}]);
//# sourceMappingURL=2348.96c1d4fd.chunk.js.map