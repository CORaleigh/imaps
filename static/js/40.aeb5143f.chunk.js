(this.webpackJsonpimaps=this.webpackJsonpimaps||[]).push([[40],{1083:function(e,t,n){"use strict";n.r(t),n.d(t,"ElevationQuery",(function(){return R})),n.d(t,"GeometryDescriptor",(function(){return O})),n.d(t,"getFinestLodIndex",(function(){return I}));var i=n(137),o=n(139),s=n(141),a=n(158),r=n(230),l=n(175),c=n(252),u=n(162),h=n(171),f=n(278),d=(n(128),n(129)),p=n(191),m=n(306);n(149);const y=d.a.getLogger("esri.layers.support.ElevationSampler");class x{queryElevation(e){return function(e,t){const n=g(e,t.spatialReference);if(!n)return null;switch(e.type){case"point":!function(e,t,n){e.z=Object(i.r)(n.elevationAt(t),0)}(e,n,t);break;case"polyline":!function(e,t,n){w.spatialReference=t.spatialReference;const o=e.hasM&&!e.hasZ;for(let s=0;s<e.paths.length;s++){const a=e.paths[s],r=t.paths[s];for(let e=0;e<a.length;e++){const t=a[e],s=r[e];w.x=s[0],w.y=s[1],o&&(t[3]=t[2]),t[2]=Object(i.r)(n.elevationAt(w),0)}}e.hasZ=!0}(e,n,t);break;case"multipoint":!function(e,t,n){w.spatialReference=t.spatialReference;const o=e.hasM&&!e.hasZ;for(let s=0;s<e.points.length;s++){const a=e.points[s],r=t.points[s];w.x=r[0],w.y=r[1],o&&(a[3]=a[2]),a[2]=Object(i.r)(n.elevationAt(w),0)}e.hasZ=!0}(e,n,t)}return e}(e.clone(),this)}on(){return M}projectIfRequired(e,t){return g(e,t)}}class v extends x{constructor(e,t,n){super(),this.tile=e,this.noDataValue=n,this.extent=Object(h.r)(e.tile.extent,t.spatialReference);const i=Object(u.f)(t.spatialReference),o=t.lodAt(e.tile.level).resolution*i;this.demResolution={min:o,max:o}}get spatialReference(){return this.extent.spatialReference}contains(e){const t=this.projectIfRequired(e,this.spatialReference);return Object(m.e)(this.extent,t)}elevationAt(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;if(!this.contains(e)){const t=this.extent,n=`${t.xmin}, ${t.ymin}, ${t.xmax}, ${t.ymax}`;y.warn("#elevationAt()",`Point used to sample elevation (${e.x}, ${e.y}) is outside of the sampler extent (${n})`)}return this.tile.sample(t.x,t.y)}}class T extends x{constructor(e,t,n){let i;super(),"number"==typeof t?(this.noDataValue=t,i=null):(i=t,this.noDataValue=n),this.samplers=i?e.map((e=>new v(e,i,this.noDataValue))):e;const o=this.samplers[0];if(o){this.extent=o.extent.clone();const{min:e,max:t}=o.demResolution;this.demResolution={min:e,max:t};for(let n=1;n<this.samplers.length;n++){const e=this.samplers[n];this.extent.union(e.extent),this.demResolution.min=Math.min(this.demResolution.min,e.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,e.demResolution.max)}}else this.extent=Object(h.r)(Object(h.i)(),i.spatialReference),this.demResolution={min:0,max:0}}get spatialReference(){return this.extent.spatialReference}elevationAt(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;for(const n of this.samplers)if(n.contains(t))return n.elevationAt(t);return y.warn("#elevationAt()",`Point used to sample elevation (${e.x}, ${e.y}) is outside of the sampler`),null}}function g(e,t){const n=e.spatialReference;return n.equals(t)?e:Object(p.a)(n,t)?Object(p.d)(e,t):(y.error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),null)}const w=new a.a,M={remove(){}};class b{constructor(e,t){if(this.tile=e,!t)return void(this.samplerData=null);const n=this.tile.extent;this.samplerData={pixelData:t.values,width:t.width,height:t.height,safeWidth:.99999999*(t.width-1),noDataValue:t.noDataValue,dx:(t.width-1)/(n[2]-n[0]),dy:(t.width-1)/(n[3]-n[1]),x0:n[0],y1:n[3]}}sample(e,t){if(this.samplerData)return function(e,t,n){const{safeWidth:i,width:o,pixelData:s,noDataValue:a}=e,r=_(e.dy*(e.y1-n),0,i),l=_(e.dx*(t-e.x0),0,i),c=Math.floor(r),u=Math.floor(l),h=c*o+u,f=h+o,d=s[h],p=s[f],m=s[h+1],y=s[f+1];if(d!==a&&p!==a&&m!==a&&y!==a){const e=l-u,t=d+(m-d)*e;return t+(p+(y-p)*e-t)*(r-c)}}(this.samplerData,e,t)}}function _(e,t,n){return e<t?t:e>n?n:e}class R{async queryAll(e,t,n){if(!(e=n&&n.ignoreInvisibleLayers?e.filter((e=>e.visible)):e.slice()).length)throw new o.a("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const i=O.fromGeometry(t);let s=!1;n&&n.returnSampleInfo||(s=!0);const a={...A,...n,returnSampleInfo:!0},r=await this.query(e[e.length-1],i,a),l=await this._queryAllContinue(e,r,a);return l.geometry=l.geometry.export(),s&&delete l.sampleInfo,l}async query(e,t,n){if(!e)throw new o.a("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof O)&&"point"!==t.type&&"multipoint"!==t.type&&"polyline"!==t.type)throw new o.a("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const i={...A,...n},s=new q(e,t.spatialReference,i),a=i.signal;return await e.load({signal:a}),await this._createGeometryDescriptor(s,t,a),await this._selectTiles(s,a),await this._populateElevationTiles(s,a),this._sampleGeometryWithElevation(s),this._createQueryResult(s,a)}async createSampler(e,t,n){if(!e)throw new o.a("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new o.a("elevation-query:invalid-extent","Invalid or undefined extent");const i={...A,...n};return this._createSampler(e,t,i)}async createSamplerAll(e,t,n){if(!(e=n&&n.ignoreInvisibleLayers?e.filter((e=>e.visible)):e.slice()).length)throw new o.a("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new o.a("elevation-query:invalid-extent","Invalid or undefined extent");const i={...A,...n,returnSampleInfo:!0},s=await this._createSampler(e[e.length-1],t,i);return this._createSamplerAllContinue(e,t,s,i)}async _createSampler(e,t,n,i){const o=n.signal;await e.load({signal:o});const s=t.spatialReference,a=e.tileInfo.spatialReference;s.equals(a)||(await Object(f.f)([{source:s,dest:a}],{signal:o}),t=Object(f.j)(t,a));const r=new E(e,t,n,i);return await this._selectTiles(r,o),await this._populateElevationTiles(r,o),new T(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)}async _createSamplerAllContinue(e,t,n,i){if(e.pop(),!e.length)return n;const o=n.samplers.map((e=>Object(h.m)(e.extent))),s=await this._createSampler(e[e.length-1],t,i,o);if(0===s.samplers.length)return n;const a=n.samplers.concat(s.samplers),r=new T(a,i.noDataValue);return this._createSamplerAllContinue(e,t,r,i)}async _queryAllContinue(e,t,n){const i=e.pop(),o=t.geometry.coordinates,s=[],a=[];for(let c=0;c<o.length;c++){const n=t.sampleInfo[c];n.demResolution>=0?n.source||(n.source=i):e.length&&(s.push(o[c]),a.push(c))}if(!e.length||0===s.length)return t;const r=t.geometry.clone(s),l=await this.query(e[e.length-1],r,n);return a.forEach(((e,n)=>{o[e].z=l.geometry.coordinates[n].z,t.sampleInfo[e].demResolution=l.sampleInfo[n].demResolution})),this._queryAllContinue(e,t,n)}async _createQueryResult(e,t){const n={geometry:(await e.geometry.project(e.outSpatialReference,t)).export(),noDataValue:e.options.noDataValue};return e.options.returnSampleInfo&&(n.sampleInfo=this._extractSampleInfo(e)),e.geometry.coordinates.forEach((e=>{e.tile=null,e.elevationTile=null})),n}async _createGeometryDescriptor(e,t,n){let i;const s=e.layer.tileInfo.spatialReference;if(t instanceof O?i=await t.project(s,n):(await Object(f.f)([{source:t.spatialReference,dest:s}],{signal:n}),i=Object(f.j)(t,s)),!i)throw new o.a("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${s.wkid}'`);e.geometry=O.fromGeometry(i)}async _selectTiles(e,t){const n=e.options.demResolution;if("geometry"===e.type&&this._preselectOutsideLayerExtent(e),"number"==typeof n)this._selectTilesClosestResolution(e);else if("finest-contiguous"===n)await this._selectTilesFinestContiguous(e,t);else{if("auto"!==n)throw new o.a("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${n}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(e,t)}}_preselectOutsideLayerExtent(e){const t=new b(null);t.sample=()=>e.options.noDataValue,e.outsideExtentTile=t;const n=e.layer.fullExtent;e.geometry.coordinates.forEach((e=>{const i=e.x,o=e.y;(i<n.xmin||i>n.xmax||o<n.ymin||o>n.ymax)&&(e.elevationTile=t)}))}_selectTilesClosestResolution(e){const t=e.layer.tileInfo,n=this._findNearestDemResolutionLODIndex(t,e.options.demResolution);e.selectTilesAtLOD(n)}_findNearestDemResolutionLODIndex(e,t){const n=t/Object(u.f)(e.spatialReference);let i=e.lods[0],o=0;for(let s=1;s<e.lods.length;s++){const t=e.lods[s];Math.abs(t.resolution-n)<Math.abs(i.resolution-n)&&(i=t,o=s)}return o}async _selectTilesFinestContiguous(e,t){const n=I(e.layer.tileInfo,e.options.minDemResolution);await this._selectTilesFinestContiguousAt(e,n,t)}async _selectTilesFinestContiguousAt(e,t,n){const i=e.layer;if(e.selectTilesAtLOD(t),t<0)return;const a=i.tilemapCache,r=e.getTilesToFetch();try{if(a)await Object(s.x)(Promise.all(r.map((e=>a.fetchAvailability(e.level,e.row,e.col,{signal:n})))),n);else if(await this._populateElevationTiles(e,n),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new o.a("elevation-query:has-unavailable-tiles")}catch(l){Object(s.t)(l),await this._selectTilesFinestContiguousAt(e,t-1,n)}}async _populateElevationTiles(e,t){const n=e.getTilesToFetch(),o={},a=e.options.cache,r=e.options.noDataValue,l=n.map((async n=>{const s=`${e.layer.uid}:${n.id}:${r}`,l=Object(i.k)(a)?a.get(s):null,c=Object(i.k)(l)?l:await e.layer.fetchTile(n.level,n.row,n.col,{noDataValue:r,signal:t});Object(i.k)(a)&&a.put(s,c),o[n.id]=new b(n,c)}));await Object(s.x)(Object(s.j)(l),t),e.populateElevationTiles(o)}async _selectTilesAuto(e,t){this._selectTilesAutoFinest(e),this._reduceTilesForMaximumRequests(e);const n=e.layer.tilemapCache;if(!n)return this._selectTilesAutoPrefetchUpsample(e,t);const i=e.getTilesToFetch(),o={},a=i.map((async e=>{const i={id:null,level:0,row:0,col:0,extent:Object(h.i)()},a=await Object(c.c)(n.fetchAvailabilityUpsample(e.level,e.row,e.col,i,{signal:t}));!1===a.ok?Object(s.t)(a.error):o[e.id]=i}));await Object(s.x)(Promise.all(a),t),e.remapTiles(o)}_reduceTilesForMaximumRequests(e){const t=e.layer.tileInfo;let n=0;const i={},o=e=>{e.id in i?i[e.id]++:(i[e.id]=1,n++)},s=e=>{const t=i[e.id];1===t?(delete i[e.id],n--):i[e.id]=t-1};e.forEachTileToFetch(o,s);let a=!0;for(;a&&(a=!1,e.forEachTileToFetch((i=>{n<=e.options.maximumAutoTileRequests||(s(i),t.upsampleTile(i)&&(a=!0),o(i))}),s),a););}_selectTilesAutoFinest(e){const t=I(e.layer.tileInfo,e.options.minDemResolution);e.selectTilesAtLOD(t,e.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(e,t){const n=e.layer.tileInfo;await this._populateElevationTiles(e,t);let i=!1;e.forEachTileToFetch(((e,t)=>{n.upsampleTile(e)?i=!0:t()})),i&&await this._selectTilesAutoPrefetchUpsample(e,t)}_sampleGeometryWithElevation(e){e.geometry.coordinates.forEach((t=>{const n=t.elevationTile;let i=e.options.noDataValue;if(n){const e=n.sample(t.x,t.y);void 0!==e?i=e:t.elevationTile=null}t.z=i}))}_extractSampleInfo(e){const t=e.layer.tileInfo,n=Object(u.f)(t.spatialReference);return e.geometry.coordinates.map((i=>{let o=-1;return i.elevationTile&&i.elevationTile!==e.outsideExtentTile&&(o=t.lodAt(i.elevationTile.tile.level).resolution*n),{demResolution:o}}))}}class O{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const t=new O;return t.geometry=this.geometry,t.spatialReference=this.spatialReference,t.coordinates=e||this.coordinates.map((e=>this._cloneCoordinate(e))),t._exporter=this._exporter,t}async project(e,t){if(this.spatialReference.equals(e))return this.clone();await Object(f.f)([{source:this.spatialReference,dest:e}],{signal:t});const n=new r.a({spatialReference:this.spatialReference,points:this.coordinates.map((e=>[e.x,e.y]))}),i=Object(f.j)(n,e);if(!i)return null;const o=this.coordinates.map(((e,t)=>{const n=this._cloneCoordinate(e),o=i.points[t];return n.x=o[0],n.y=o[1],n})),s=this.clone(o);return s.spatialReference=e,s}_cloneCoordinate(e){return{x:e.x,y:e.y,z:e.z,m:e.m,tile:null,elevationTile:null}}static fromGeometry(e){const t=new O;if(t.geometry=e,t.spatialReference=e.spatialReference,e instanceof O)t.coordinates=e.coordinates.map((e=>t._cloneCoordinate(e))),t._exporter=(t,n)=>{const i=e.clone(t);return i.spatialReference=n,i};else switch(e.type){case"point":{const n=e,{hasZ:i,hasM:o}=n;t.coordinates=i&&o?[{x:n.x,y:n.y,z:n.z,m:n.m}]:i?[{x:n.x,y:n.y,z:n.z}]:o?[{x:n.x,y:n.y,m:n.m}]:[{x:n.x,y:n.y}],t._exporter=(t,n)=>e.hasM?new a.a(t[0].x,t[0].y,t[0].z,t[0].m,n):new a.a(t[0].x,t[0].y,t[0].z,n);break}case"multipoint":{const n=e,{hasZ:i,hasM:o}=n;t.coordinates=i&&o?n.points.map((e=>({x:e[0],y:e[1],z:e[2],m:e[3]}))):i?n.points.map((e=>({x:e[0],y:e[1],z:e[2]}))):o?n.points.map((e=>({x:e[0],y:e[1],m:e[2]}))):n.points.map((e=>({x:e[0],y:e[1]}))),t._exporter=(t,n)=>e.hasM?new r.a({points:t.map((e=>[e.x,e.y,e.z,e.m])),hasZ:!0,hasM:!0,spatiaReference:n}):new r.a(t.map((e=>[e.x,e.y,e.z])),n);break}case"polyline":{const n=e,i=[],o=[],{hasZ:s,hasM:a}=e;let r=0;for(const e of n.paths)if(o.push([r,r+e.length]),r+=e.length,s&&a)for(const t of e)i.push({x:t[0],y:t[1],z:t[2],m:t[3]});else if(s)for(const t of e)i.push({x:t[0],y:t[1],z:t[2]});else if(a)for(const t of e)i.push({x:t[0],y:t[1],m:t[2]});else for(const t of e)i.push({x:t[0],y:t[1]});t.coordinates=i,t._exporter=(t,n)=>{const i=e.hasM?t.map((e=>[e.x,e.y,e.z,e.m])):t.map((e=>[e.x,e.y,e.z])),s=o.map((e=>i.slice(e[0],e[1])));return new l.a({paths:s,hasM:e.hasM,hasZ:!0,spatialReference:n})};break}}return t}}class j{constructor(e,t){this.layer=e,this.options=t}}class q extends j{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach((e=>e.tile=null));else{const t=this.layer.tileInfo,n=t.lods[e].level;this.geometry.coordinates.forEach((e=>{e.tile=t.tileAt(n,e.x,e.y)}))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((e=>!e.elevationTile))}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const t of this.geometry.coordinates)!t.elevationTile&&t.tile&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(const t of this.geometry.coordinates)t.tile=e[t.tile.id]}getTilesToFetch(){const e={},t=[];for(const n of this.geometry.coordinates){const i=n.tile;n.elevationTile||!n.tile||e[i.id]||(e[i.id]=i,t.push(i))}return t}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,(()=>t.tile=null))}}class E extends j{constructor(e,t,n,i){super(e,n),this.type="extent",this.elevationTiles=[],this.candidateTiles=[],this.fetchedCandidates=new Set,this.extent=t.intersection(e.fullExtent),this.maskExtents=i}selectTilesAtLOD(e,t){const n=this._maximumLodForRequests(t),i=Math.min(n,e);i<0?this.candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(e){const t=this.layer.tileInfo;if(!e)return t.lods.length-1;const n=this.extent;for(let i=t.lods.length-1;i>=0;i--){const o=t.lods[i],s=o.resolution*t.size[0],a=o.resolution*t.size[1];if(Math.ceil(n.width/s)*Math.ceil(n.height/a)<=e)return i}return-1}allElevationTilesFetched(){return this.candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this.fetchedCandidates.clear()}populateElevationTiles(e){for(const t of this.candidateTiles){const n=e[t.id];n&&(this.fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles.map((t=>e[t.id])))}getTilesToFetch(){return this.candidateTiles}forEachTileToFetch(e,t){const n=this.candidateTiles;this.candidateTiles=[],n.forEach((n=>{if(this.fetchedCandidates.has(n))return void(t&&t(n));let i=!1;e(n,(()=>i=!0)),i?t&&t(n):this.candidateTiles.push(n)})),this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles,t)}_uniqueNonOverlappingTiles(e,t){const n={},i=[];for(const s of e)n[s.id]?t&&t(s):(n[s.id]=s,i.push(s));const o=i.sort(((e,t)=>e.level-t.level));return o.filter(((e,n)=>{for(let i=0;i<n;i++)if(Object(h.d)(o[i].extent,e.extent))return t&&t(e),!1;return!0}))}_selectCandidateTilesCoveringExtentAt(e){this.candidateTiles.length=0;const t=this.layer.tileInfo,n=t.lods[e],i=this.extent,o=t.tileAt(n.level,i.xmin,i.ymin),s=n.resolution*t.size[0],a=n.resolution*t.size[1],r=Math.ceil((i.xmax-o.extent[0])/s),l=Math.ceil((i.ymax-o.extent[1])/a);for(let c=0;c<l;c++)for(let e=0;e<r;e++){const n={id:null,level:o.level,row:o.row-c,col:o.col+e};t.updateTileInfo(n),this._tileIsMasked(n)||this.candidateTiles.push(n)}}_tileIsMasked(e){return!!this.maskExtents&&this.maskExtents.some((t=>Object(h.d)(t,e.extent)))}}function I(e,t){let n=e.lods.length-1;if(t>0){const i=e.lods.findIndex((e=>e.resolution<t));0===i?n=0:i>0&&(n=i-1)}return n}const A={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};t.default=R},151:function(e,t,n){"use strict";function i(){return[0,0,0]}function o(e){return[e[0],e[1],e[2]]}function s(e,t,n){return[e,t,n]}function a(e){const t=[0,0,0],n=Math.min(3,e.length);for(let i=0;i<n;++i)t[i]=e[i];return t}function r(e,t){return new Float64Array(e,t,3)}function l(){return[0,0,0]}function c(){return s(1,1,1)}function u(){return s(1,0,0)}function h(){return s(0,1,0)}function f(){return s(0,0,1)}n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d})),n.d(t,"c",(function(){return r})),n.d(t,"d",(function(){return o})),n.d(t,"e",(function(){return i})),n.d(t,"f",(function(){return a})),n.d(t,"g",(function(){return s}));const d=[0,0,0],p=c(),m=u(),y=h(),x=f();Object.freeze({__proto__:null,create:i,clone:o,fromValues:s,fromArray:a,createView:r,zeros:l,ones:c,unitX:u,unitY:h,unitZ:f,ZEROS:d,ONES:p,UNIT_X:m,UNIT_Y:y,UNIT_Z:x})},157:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return d})),n.d(t,"c",(function(){return R})),n.d(t,"d",(function(){return f})),n.d(t,"e",(function(){return l})),n.d(t,"f",(function(){return g})),n.d(t,"g",(function(){return T})),n.d(t,"h",(function(){return w})),n.d(t,"i",(function(){return c})),n.d(t,"j",(function(){return a})),n.d(t,"k",(function(){return m})),n.d(t,"l",(function(){return M})),n.d(t,"m",(function(){return C})),n.d(t,"n",(function(){return p})),n.d(t,"o",(function(){return s})),n.d(t,"p",(function(){return q})),n.d(t,"q",(function(){return v})),n.d(t,"r",(function(){return y})),n.d(t,"s",(function(){return x})),n.d(t,"t",(function(){return _})),n.d(t,"u",(function(){return E})),n.d(t,"v",(function(){return r})),n.d(t,"w",(function(){return b})),n.d(t,"x",(function(){return k})),n.d(t,"y",(function(){return z})),n.d(t,"z",(function(){return D}));var i=n(151),o=n(227);function s(e){const t=e[0],n=e[1],i=e[2];return Math.sqrt(t*t+n*n+i*i)}function a(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function r(e,t,n,i){return e[0]=t,e[1]=n,e[2]=i,e}function l(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function c(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function u(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function h(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e}function f(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function d(e,t,n,i){return e[0]=t[0]+n[0]*i,e[1]=t[1]+n[1]*i,e[2]=t[2]+n[2]*i,e}function p(e,t){const n=t[0]-e[0],i=t[1]-e[1],o=t[2]-e[2];return Math.sqrt(n*n+i*i+o*o)}function m(e,t){const n=t[0]-e[0],i=t[1]-e[1],o=t[2]-e[2];return n*n+i*i+o*o}function y(e){const t=e[0],n=e[1],i=e[2];return t*t+n*n+i*i}function x(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}function v(e,t){const n=t[0],i=t[1],o=t[2];let s=n*n+i*i+o*o;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e}function T(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function g(e,t,n){const i=t[0],o=t[1],s=t[2],a=n[0],r=n[1],l=n[2];return e[0]=o*l-s*r,e[1]=s*a-i*l,e[2]=i*r-o*a,e}function w(e,t,n,i){const o=t[0],s=t[1],a=t[2];return e[0]=o+i*(n[0]-o),e[1]=s+i*(n[1]-s),e[2]=a+i*(n[2]-a),e}function M(e,t,n){const i=t[0],o=t[1],s=t[2];return e[0]=n[0]*i+n[4]*o+n[8]*s+n[12],e[1]=n[1]*i+n[5]*o+n[9]*s+n[13],e[2]=n[2]*i+n[6]*o+n[10]*s+n[14],e}function b(e,t,n){const i=t[0],o=t[1],s=t[2];return e[0]=i*n[0]+o*n[3]+s*n[6],e[1]=i*n[1]+o*n[4]+s*n[7],e[2]=i*n[2]+o*n[5]+s*n[8],e}function _(e,t,n){const i=n[0],o=n[1],s=n[2],a=n[3],r=t[0],l=t[1],c=t[2];let u=o*c-s*l,h=s*r-i*c,f=i*l-o*r,d=o*f-s*h,p=s*u-i*f,m=i*h-o*u;const y=2*a;return u*=y,h*=y,f*=y,d*=2,p*=2,m*=2,e[0]=r+u+d,e[1]=l+h+p,e[2]=c+f+m,e}function R(e,t,n,i){const o=[],s=[];return o[0]=t[0]-n[0],o[1]=t[1]-n[1],o[2]=t[2]-n[2],s[0]=o[0]*Math.cos(i)-o[1]*Math.sin(i),s[1]=o[0]*Math.sin(i)+o[1]*Math.cos(i),s[2]=o[2],e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e}const O=Object(i.e)(),j=Object(i.e)();function q(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}const E=c,I=u,A=h,D=p,z=m,C=s,k=y;Object.freeze({__proto__:null,length:s,copy:a,set:r,add:l,subtract:c,multiply:u,divide:h,ceil:function(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},floor:function(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},min:function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},max:function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},round:function(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},scale:f,scaleAndAdd:d,distance:p,squaredDistance:m,squaredLength:y,negate:x,inverse:function(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e},normalize:v,dot:T,cross:g,lerp:w,hermite:function(e,t,n,i,o,s){const a=s*s,r=a*(2*s-3)+1,l=a*(s-2)+s,c=a*(s-1),u=a*(3-2*s);return e[0]=t[0]*r+n[0]*l+i[0]*c+o[0]*u,e[1]=t[1]*r+n[1]*l+i[1]*c+o[1]*u,e[2]=t[2]*r+n[2]*l+i[2]*c+o[2]*u,e},bezier:function(e,t,n,i,o,s){const a=1-s,r=a*a,l=s*s,c=r*a,u=3*s*r,h=3*l*a,f=l*s;return e[0]=t[0]*c+n[0]*u+i[0]*h+o[0]*f,e[1]=t[1]*c+n[1]*u+i[1]*h+o[1]*f,e[2]=t[2]*c+n[2]*u+i[2]*h+o[2]*f,e},random:function(e,t){t=t||1;const n=2*Object(o.b)()*Math.PI,i=2*Object(o.b)()-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},transformMat4:M,transformMat3:b,transformQuat:_,rotateX:function(e,t,n,i){const o=[],s=[];return o[0]=t[0]-n[0],o[1]=t[1]-n[1],o[2]=t[2]-n[2],s[0]=o[0],s[1]=o[1]*Math.cos(i)-o[2]*Math.sin(i),s[2]=o[1]*Math.sin(i)+o[2]*Math.cos(i),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},rotateY:function(e,t,n,i){const o=[],s=[];return o[0]=t[0]-n[0],o[1]=t[1]-n[1],o[2]=t[2]-n[2],s[0]=o[2]*Math.sin(i)+o[0]*Math.cos(i),s[1]=o[1],s[2]=o[2]*Math.cos(i)-o[0]*Math.sin(i),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2],e},rotateZ:R,angle:function(e,t){a(O,e),a(j,t),v(O,O),v(j,j);const n=T(O,j);return n>1?0:n<-1?Math.PI:Math.acos(n)},str:function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},exactEquals:q,equals:function(e,t){const n=e[0],i=e[1],s=e[2],a=t[0],r=t[1],l=t[2];return Math.abs(n-a)<=o.a*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(i-r)<=o.a*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(s-l)<=o.a*Math.max(1,Math.abs(s),Math.abs(l))},sub:E,mul:I,div:A,dist:D,sqrDist:z,len:C,sqrLen:k})},227:function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return l})),n.d(t,"d",(function(){return r}));const i=1e-6,o=Math.random,s=Math.PI/180,a=180/Math.PI;function r(e){return e*s}function l(e){return e*a}Object.freeze({__proto__:null,EPSILON:i,RANDOM:o,toRadian:r,toDegree:l,equals:function(e,t){return Math.abs(e-t)<=i*Math.max(1,Math.abs(e),Math.abs(t))}})},252:function(e,t,n){"use strict";n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return s})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return r}));var i=n(141);function o(e,t,n){return Object(i.j)(e.map(((e,i)=>t.apply(n,[e,i]))))}function s(e,t,n){return Object(i.j)(e.map(((e,i)=>t.apply(n,[e,i])))).then((e=>e.map((e=>e.value))))}function a(e){return e.then((e=>({ok:!0,value:e}))).catch((e=>({ok:!1,error:e})))}function r(e){return e.then((e=>({ok:!0,value:e}))).catch((e=>(Object(i.t)(e),{ok:!1,error:e})))}}}]);
//# sourceMappingURL=40.aeb5143f.chunk.js.map