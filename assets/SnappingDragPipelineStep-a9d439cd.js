import{J as l,aT as K,E as Q,e as h,L as tt,j8 as b,a8 as et,at as f,aS as nt,y as m,a as at,aw as $,d2 as R,bW as w,ai as it,a2 as ot,d0 as O,d9 as U,cF as rt,af as st,bS as lt,z as ct,a4 as ut,fC as pt,a6 as dt,a5 as ht,bb as ft,g_ as mt}from"./index-53e0d3f6.js";import{k as yt,M as N}from"./hydratedFeatures-fee269f9.js";import{i as k}from"./drawUtils-e1157c45.js";import{a as gt}from"./SnappingContext-266fe79c.js";function vt(e,t){return e===t||l(e)&&l(t)&&K(e.spatialReference,t.spatialReference)&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.m===t.m}var x;(function(e){e[e.WhenToolEditable=0]="WhenToolEditable",e[e.WhenToolNotEditable=1]="WhenToolNotEditable",e[e.Always=2]="Always"})(x||(x={}));class Et{constructor(){this._isToolEditable=!0,this._manipulators=new Q,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(t){this._isToolEditable=t}get length(){return this._manipulators.length}add(t,n=x.WhenToolEditable){this.addMany([t],n)}addMany(t,n=x.WhenToolEditable){for(const a of t){const i={manipulator:a,visibilityPredicate:n,attached:!1};this._manipulators.add(i),this._attached&&this._updateManipulatorAttachment(i)}}remove(t){for(let n=0;n<this._manipulators.length;n++)if(this._manipulators.getItemAt(n).manipulator===t){const a=this._manipulators.splice(n,1)[0];this._detachManipulator(a);break}}removeAll(){this._manipulators.forEach(t=>{this._detachManipulator(t)}),this._manipulators.removeAll()}attach(){this._manipulators.forEach(t=>{this._updateManipulatorAttachment(t)}),this._attached=!0}detach(){this._manipulators.forEach(t=>{this._detachManipulator(t)}),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach(({manipulator:t})=>{t.destroy&&t.destroy()}),this._manipulators.destroy(),this._resourceContexts=null}on(t,n){return this._manipulators.on(t,a=>{n(a)})}forEach(t){for(const n of this._manipulators.items)t(n)}some(t){return this._manipulators.items.some(t)}toArray(){const t=[];return this.forEach(n=>t.push(n.manipulator)),t}intersect(t,n){let a=null,i=Number.MAX_VALUE;return this._manipulators.forEach(({manipulator:o,attached:s})=>{if(!s||!o.interactive)return;const r=o.intersectionDistance(t,n);l(r)&&r<i&&(i=r,a=o)}),a}_updateManipulatorAttachment(t){this._isManipulatorItemVisible(t)?this._attachManipulator(t):this._detachManipulator(t)}_attachManipulator(t){t.attached||(t.manipulator.attach&&t.manipulator.attach(this._resourceContexts),t.attached=!0)}_detachManipulator(t){if(!t.attached)return;const n=t.manipulator;n.grabbing=!1,n.dragging=!1,n.hovering=!1,n.selected=!1,n.detach&&n.detach(this._resourceContexts),t.attached=!1}_isManipulatorItemVisible(t){return t.visibilityPredicate===x.Always||(this._isToolEditable?t.visibilityPredicate===x.WhenToolEditable:t.visibilityPredicate===x.WhenToolNotEditable)}}let d=class extends tt{constructor(e){super(e),this.manipulators=new Et,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[b.MANAGER,!0],[b.USER,!0]]),this._creationFinishedResolver=et()}get active(){return this.view!=null&&this.view.activeTool===this}set visible(e){this._get("visible")!==e&&(this._set("visible",e),this._syncVisible())}get editable(){return this.getEditableFlag(b.USER)}set editable(e){this.setEditableFlag(b.USER,e)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){f(this.view)?nt.getLogger(this.declaredClass).error("Can't activate tool if view is not defined."):(this.view.focus(),this.onActivate())}deactivate(){this.onDeactivate()}handleInputEvent(e){this.onInputEvent(e)}handleInputEventAfter(e){this.onInputEventAfter(e)}setEditableFlag(e,t){this._editableFlags.set(e,t),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),e===b.USER&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(e){return this._editableFlags.get(e)??!1}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(e){}onInputEventAfter(e){}get internallyEditable(){return this.getEditableFlag(b.USER)&&this.getEditableFlag(b.MANAGER)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized){if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};h([m({constructOnly:!0})],d.prototype,"view",void 0),h([m({readOnly:!0})],d.prototype,"active",null),h([m({value:!0})],d.prototype,"visible",null),h([m({value:!0})],d.prototype,"editable",null),h([m({readOnly:!0})],d.prototype,"manipulators",void 0),h([m({readOnly:!0})],d.prototype,"updating",null),h([m()],d.prototype,"cursor",null),h([m({readOnly:!0})],d.prototype,"automaticManipulatorSelection",void 0),h([m()],d.prototype,"hasFocusedManipulators",null),h([m()],d.prototype,"hasGrabbedManipulators",void 0),h([m()],d.prototype,"hasHoveredManipulators",void 0),h([m()],d.prototype,"firstGrabbedManipulator",void 0),h([m({readOnly:!0})],d.prototype,"created",void 0),h([m({readOnly:!0})],d.prototype,"removeIncompleteOnCancel",void 0),d=h([at("esri.views.interactive.InteractiveToolBase")],d);function bt(e,t){let n=null,a=null;return i=>{if(i.action==="cancel")return void(l(a)&&(a.execute({action:"cancel"}),n=null,a=null));const o={action:i.action,screenStart:i.start,screenEnd:i.screenPoint};i.action==="start"&&f(n)&&(n=new S,a=new S,t(e,n,a,i.pointerType,o)),l(n)&&n.execute(o),i.action==="end"&&l(n)&&(n=null,a=null)}}function Ot(e,t){return e.events.on("drag",bt(e,t))}function Ut(e,t){const n=[e.x,e.y,e.z??0],a=t,i=[Math.cos(a),Math.sin(a)],o=Math.sqrt(i[0]*i[0]+i[1]*i[1]);if(o===0)return null;i[0]/=o,i[1]/=o;const s=r=>{const c=(r.x-n[0])*i[0]+(r.y-n[1])*i[1];r.x=n[0]+c*i[0],r.y=n[1]+c*i[1]};return r=>(s(r.mapStart),s(r.mapEnd),{...r,axis:i})}function xt(e,t){let n=null;return a=>{if(a.action==="start"&&(n=_t(e,a.mapStart.spatialReference,t)),f(n))return null;const i=a.mapEnd.x-a.mapStart.x,o=a.mapEnd.y-a.mapStart.y,s=a.mapEnd.z-a.mapStart.z;return n.move(i,o,s),{...a,translationX:i,translationY:o,translationZ:s}}}function q(e,t){return f(e)?null:e.spatialReference.equals(t)?e.clone():w(e,t)}function _t(e,t,n){const a=e.geometry,i=yt(t);if(f(a))return null;if(a.type==="mesh")return St(e,a,i,n);const o=q(a,i),s=a.spatialReference;return f(o)?null:{move:(r,c,u)=>{const p=k(o.clone(),r,c,u);p.spatialReference.equals(s)?e.geometry=p:e.geometry=w(p,s)}}}function St(e,t,n,a){if(l(t.transform))return Mt(e,t,t.transform,n);if(!t.spatialReference.equals(n))return null;let i=0,o=0,s=0;return{move:(r,c,u)=>{const p=r-i,E=c-o,v=u-s;if(p||E||v){const y=new it(t.origin.x+p,t.origin.y+E,t.origin.z+v,t.origin.spatialReference);t.centerAt(y,{geographic:a===ot.Global}),e.notifyGeometryChanged(),i=r,o=c,s=u}}}}function Mt(e,t,n,a){const i=q(n.getOriginPoint(t.spatialReference),a),o=t.spatialReference;return f(i)?null:{move:(s,r,c)=>{const u=k(i.clone(),s,r,c);if(u.spatialReference.equals(o))n.origin=O(u.x,u.y,u.z);else{const p=w(u,o);l(p)&&(n.origin=O(p.x,p.y,p.z))}e.notifyMeshTransformChanged(),e.notifyGeometryChanged()}}}function Ht(e,t=null,n){var s;let a=null;const i=l(t)&&!((s=e.spatialReference)!=null&&s.equals(t))?r=>l(r)?w(r,t):r:r=>r,o={exclude:[],...n};return r=>{if(r.action==="start"&&(a=i(e.toMap(r.screenStart,o))),f(a))return null;const c=i(e.toMap(r.screenEnd,o));return l(c)?{...r,mapStart:a,mapEnd:c}:null}}function Wt(e,t){const n=e.map(a=>$(xt(a,t))).filter(a=>l(a));return a=>{const i=a.mapEnd.x-a.mapStart.x,o=a.mapEnd.y-a.mapStart.y,s=a.mapEnd.z-a.mapStart.z;return n.forEach(r=>r(a)),{...a,translationX:i,translationY:o,translationZ:s}}}function wt(e,t){const n=new Map;for(const a of t)n.set(a,st(e[a]));return a=>(n.forEach((i,o)=>{e[o]=i}),a)}function Pt(e){return l(e.geometry)&&e.geometry.type==="mesh"?At(e,e.geometry):wt(e,["geometry"])}function At(e,t){const n=l(t.transform)?t.transform.clone():null,a=t.vertexAttributes.clonePositional();return i=>(t.transform=n,t.vertexAttributes=a,e.notifyGeometryChanged(),i)}function Nt(e){const t=e.map(n=>$(Pt(n))).filter(n=>l(n));return n=>(t.forEach(a=>a(n)),n)}function kt(){let e=0,t=0,n=0;return a=>{a.action==="start"&&(e=a.mapStart.x,t=a.mapStart.y,n=a.mapStart.z);const i=a.mapEnd.x-e,o=a.mapEnd.y-t,s=a.mapEnd.z-n;return e=a.mapEnd.x,t=a.mapEnd.y,n=a.mapEnd.z,{...a,mapDeltaX:i,mapDeltaY:o,mapDeltaZ:s,mapDeltaSpatialReference:a.mapStart.spatialReference}}}function qt(){let e=0,t=0;return n=>{n.action==="start"&&(e=n.screenStart.x,t=n.screenStart.y);const a=n.screenEnd.x-e,i=n.screenEnd.y-t;return e=n.screenEnd.x,t=n.screenEnd.y,{...n,screenDeltaX:a,screenDeltaY:i}}}function Vt(e,t){let n=null,a=0,i=0;return o=>{var u;if(o.action==="start"&&(n=(u=e.toScreen)==null?void 0:u.call(e,t),n!=null&&(n.x<0||n.x>e.width||n.y<0||n.y>e.height?n=null:(a=o.screenStart.x-n.x,i=o.screenStart.y-n.y))),n==null)return null;const s=U(o.screenEnd.x-a,0,e.width),r=U(o.screenEnd.y-i,0,e.height),c=lt(s,r);return o.screenStart=n,o.screenEnd=c,o}}const zt=()=>{};class S{constructor(){this.execute=zt}next(t,n=new S){return l(t)&&(this.execute=a=>{const i=t(a);l(i)&&n.execute(i)}),n}}function Xt(e,t,n=[]){if(e.type==="2d")return i=>i;let a=null;return i=>{i.action==="start"&&(a=e.toMap(i.screenStart,{exclude:n}),l(a)&&(a.z=R(a,e,t)));const o=e.toMap(i.screenEnd,{exclude:n});l(o)&&(o.z=R(o,e,t));const s=l(a)&&l(o)?{sceneStart:a,sceneEnd:o}:null;return{...i,scenePoints:s}}}function H(e,t,n){const a=rt(t.elevationProvider.getElevation(e.x,e.y,e.z??0,e.spatialReference,"scene"))??0,i=N(e);return i.z=a,i.hasZ=!0,i.z=R(i,t,n),i}function jt(e,t){if(e.type==="2d")return a=>a;let n=null;return a=>{a.action==="start"&&(n=H(a.mapStart,e,t));const i=H(a.mapEnd,e,t),o=l(n)&&l(i)?{sceneStart:n,sceneEnd:i}:null;return{...a,scenePoints:o}}}function Lt({predicate:e=()=>!0,snappingManager:t,snappingContext:n,updatingHandles:a,useZ:i=!0}){const o=new S;if(f(t))return{snappingStep:[W,o],cancelSnapping:W};let s,r=null,c=null,u=null;const p=()=>{r=dt(r),t.doneSnapping(),l(c)&&c.frameTask.remove(),c=null,s=ht(s),u=null},E=Tt(t,i,o);let v=null,y=null,I=null;return{snappingStep:[g=>{if(!e(g))return g;const{action:P}=g;if(P==="start"){const{info:M}=g,A=Rt(t.view);if(c=Ct(n,g,A),c.context.selfSnappingZ=null,!i&&l(M)){const _=It(n.coordinateHelper,M.handle.component);l(_)&&(c.context.selfSnappingZ={value:_,elevationInfo:n.elevationInfo})}}if(l(c)){const{context:M,originalScenePos:A,originalPos:_}=c,{mapEnd:Z,mapStart:F,scenePoints:j}=g,z=V(_,C(Z,F)),G=C(F,_),L={...g,action:"update"},Y=c.context,T=$t(A,j),D=t.update({point:z,scenePoint:T,context:M});if(I=D,X(Z,D,G,i),v=z,y=T,P!=="end"){const{frameTask:B}=c;f(r)&&(r=new AbortController),u=J=>{a.addPromise(ft(E({frameTask:B,event:L,context:Y,point:z,scenePoint:T,delta:G,getLastState:()=>({point:v,scenePoint:y,updatePoint:J.forceUpdate?null:I})},$(r).signal)))},u({forceUpdate:!1}),f(s)&&(s=ct(()=>t.options.effectiveEnabled,()=>u==null?void 0:u({forceUpdate:!0})))}}return P==="end"&&p(),g},o],cancelSnapping:g=>(p(),g)}}function Tt(e,t,n){return mt(async({frameTask:a,point:i,scenePoint:o,context:s,event:r,delta:c,getLastState:u},p)=>{const E=await a.schedule(()=>e.snap({point:i,scenePoint:o,context:s,signal:p}),p);if(E.valid){let v=await a.schedule(()=>E.apply(),p);const y=u();l(y.point)&&i!==y.point&&(v=e.update({point:y.point,scenePoint:y.scenePoint,context:s})),!f(y.updatePoint)&&vt(v,y.updatePoint)||(X(r.mapEnd,v,c,t),n.execute(r))}})}function Rt(e){return e.type==="3d"?e.resourceController.scheduler.registerTask(ut.SNAPPING):pt}function Ct(e,t,n){return{context:new gt({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:l(t.info)?t.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:l(t.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,originalScenePos:l(t.scenePoints)?t.scenePoints.sceneStart:null,frameTask:n}}function V(e,[t,n,a]){const i=N(e);return i.x+=t,i.y+=n,i.hasZ&&(i.z+=a),i}function $t(e,t){return f(e)||f(t)?null:V(e,C(t.sceneEnd,t.sceneStart))}function C(e,t){const n=e.hasZ&&t.hasZ?e.z-t.z:0;return[e.x-t.x,e.y-t.y,n]}function X(e,t,[n,a,i],o){e.x=t.x+n,e.y=t.y+a,o&&e.hasZ&&t.hasZ&&(e.z=t.z+i)}function It(e,t){if(!e.hasZ())return null;const n=t.vertices;let a=null;for(const i of n){const o=e.getZ(i.pos);if(l(a)&&l(o)&&Math.abs(o-a)>1e-6)return null;f(a)&&(a=o)}return a}function W(e){return e}export{Vt as C,kt as D,xt as E,Pt as M,Wt as R,S as U,Xt as X,jt as Z,qt as b,Et as e,Ut as g,vt as i,Lt as m,d as p,Nt as q,Ht as v,wt as w,Ot as x};
